
%% 
% Input: features + labels
% Output: classifiers, normalized features and parameters for normalization
% Dependency: linkAnnotationToFeature
function [] = LCH_trainAnnotationCls()

close all; clc;
always = true;

minInstancesPerClass = 20;


%     baseDname = 'C:\Assaf\LCH_CellExplorer\';
baseDname = '/project/bioinformatics/Danuser_lab/liveCellHistology/analysis/CellExplorerData/';
prefix = 'annotation2feats_14-May-2017_LBP_dLBP_1';
uniqueLabelsFname = [baseDname 'uniqueLabels.mat']; % generated by annotationStats.m
featsFname = [baseDname prefix '.mat']; % generated by linkAnnotationToFeature
clsFname = [baseDname prefix '_cls.mat'];
normDataFname = [baseDname prefix '_normData.mat'];
clsLogPrefix = [baseDname prefix '_cls'];

if ~exist(clsFname,'file') || always
    
    load(uniqueLabelsFname);% uniqueLabels
    nLables = length(uniqueLabels);
    
    classLabelPairList = getClassLabelLists();
    
    load(featsFname); % 'cellFeats','cellTypes','metEffs','dates','nAnnotCells','annotationInfo','sources'
    
    [featsAll,indsAll] = getAllMatrix(cellFeats);
    
    [meanVals,stdVals] = getNormFeats(featsAll);
     
    [...
        featsTumors,indsTumors,...
        featsCellLines, indsCellLines,...
        featsMelanocytes, indsMelanocytes...
        ]...
        = ...
        getSourceMatrix(cellFeats,sources);
    
    %     [indsTumors,indsCellLines,indsMelanocytes] = getSourceInds(sources);
    
    % Normalize
    [featsAllNorm] = setNormFeats(featsAll,meanVals,stdVals);
    [featsTumorsNorm] = setNormFeats(featsTumors,meanVals,stdVals);
    [featsCellLinesNorm] = setNormFeats(featsCellLines,meanVals,stdVals);
    [featsMelanocytesNorm] = setNormFeats(featsMelanocytes,meanVals,stdVals);
    
    % TODO: for each cell type
    
    %% Train classifiers, report errors
    [clsAll,clsAllLog] = trainActionClassifiers(featsAllNorm,indsAll,cellAnnotations,minInstancesPerClass,uniqueLabels,classLabelPairList);
    writeClsLog(clsAllLog,[clsLogPrefix '_all.txt'],'w');
    
    [clsTumors,clsTumorsLog] = trainActionClassifiers(featsTumorsNorm,indsTumors,cellAnnotations,minInstancesPerClass,uniqueLabels,classLabelPairList);
    writeClsLog(clsTumorsLog,[clsLogPrefix '_tumors.txt'],'w');
    
    [clsCellLines,clsCellLinesLog] = trainActionClassifiers(featsCellLinesNorm,indsCellLines,cellAnnotations,minInstancesPerClass,uniqueLabels,classLabelPairList);
    writeClsLog(clsCellLinesLog,[clsLogPrefix '_cellLines.txt'],'w');
    
    [clsMelanocytes,clsMelanocytesLog] = trainActionClassifiers(featsMelanocytesNorm,indsMelanocytes,cellAnnotations,minInstancesPerClass,uniqueLabels,classLabelPairList);
    writeClsLog(clsMelanocytesLog,[clsLogPrefix '_melanocytes.txt'],'w');
    
    save(clsFname,'clsAll','clsTumors','clsCellLines','clsMelanocytes');
    save(normDataFname,'meanVals','stdVals','featsAllNorm','featsTumorsNorm','featsCellLinesNorm','featsMelanocytesNorm');
end
end

%% List of paired lists.
% Each pair defines a classifier
function classLabelPairList = getClassLabelLists()
classLabelPairList = {...
    {{'<html>MULTIPLE<br>CELLS'},{'REST'}},...
    {{'<html>OUT<br>OF<br>FOCUS'},{'REST'}},...
    {{'JUNK'},{'REST'}},...
    {{'Balled'},{'REST'}},...
    {{'Blebbing'},{'REST'}},...    
    {{'Elongated'},{'REST'}},...
    {{'Long extension'},{'REST'}},...
    {{'Migration'},{'REST'}},...
    {{'Short extension'},{'REST'}},...
    {{'Smooth'},{'REST'}},...
    {{'Spread'},{'REST'}},...
    {{'Balled','Blebbing'},{'REST'}},...
    {{'Elongated','Spread'},{'REST'}},...
    {{'<html>MULTIPLE<br>CELLS','<html>OUT<br>OF<br>FOCUS','JUNK'},{'REST'}},...
    {{'Balled'},{'Blebbing'}},...
    {{'Elongated'},{'Spread'}}...    
    };
end

%%
function [featsAll,indsAll] = getAllMatrix(cellFeats)
nCells = length(cellFeats);
tmp = cellFeats{1};
nFeats = length(tmp);

indsAll = 1:nCells;

featsAll = nan(nFeats,nCells);

for icell = 1 : nCells
    curFeats = cellFeats{icell};    
    featsAll(:,icell) = curFeats;
end

end

%%
function [featsTumors,indsTumors,...
        featsCellLines, indsCellLines,...
        featsMelanocytes, indsMelanocytes]...
        ...
        = getSourceMatrix(cellFeats,sources)
    
    tmp = cellFeats{1};
    nFeats = length(tmp);
    
    indsTumors = find(strcmp('Tumors',sources));
    indsCellLines = find(strcmp('CellLines',sources));
    indsMelanocytes = find(strcmp('Melanocytes',sources));
    
    nTumors = length(indsTumors);
    nCellLines = length(indsCellLines);
    nMelanocytes = length(indsMelanocytes);
    
    featsTumors = nan(nFeats,nTumors);
    featsCellLines = nan(nFeats,nCellLines);
    featsMelanocytes = nan(nFeats,nMelanocytes);
    
    for icell = 1 : length(indsTumors)
        featsTumors(:,icell) = cellFeats{indsTumors(icell)}; 
    end
    
    for icell = 1 : length(indsCellLines)
        featsCellLines(:,icell) = cellFeats{indsCellLines(icell)}; 
    end
    
     for icell = 1 : length(indsMelanocytes)
        featsMelanocytes(:,icell) = cellFeats{indsMelanocytes(icell)}; 
     end            
end

% %%
% function [indsTumors,indsCellLines,indsMelanocytes] = getSourceInds(sources)        
%     indsTumors = find(strcmp('Tumors',sources));
%     indsCellLines = find(strcmp('CellLines',sources));
%     indsMelanocytes = find(strcmp('Melanocytes',sources));    
% end


%% 
function [clsAll,clsLog] = trainActionClassifiers(feats,inds,cellAnnotations,minInstancesPerClass,uniqueLabels,classLabelPairList)
nClassifiers = length(classLabelPairList);
clsAll = cell(1,nClassifiers);
clsLog = cell(1,nClassifiers);
for iClassifier = 1 : nClassifiers
    curClassLabelPair = classLabelPairList{iClassifier};
    [curFeats,curLabels] = selectSamples(feats,inds,cellAnnotations,uniqueLabels,curClassLabelPair);    
    
    n1 = sum(curLabels == 1);
    n2 = sum(curLabels == 2);
    
    costVal = getCostVal(n1,n2); % normalize by number of observation
    
    if (n1 < minInstancesPerClass) || (n2 < minInstancesPerClass)
        clsAll{iClassifier} = nan;
        clsLog{iClassifier} = sprintf('classifier %s - not enough observation (%d vs. %d)\n',getClsStr(curClassLabelPair),n1,n2);
    end
      
    curCls = fitcdiscr(curFeats',curLabels,'ClassNames',[1,2],'Cost',costVal);    
    clsAll{iClassifier} = curCls;
    clsLog{iClassifier} = getClsStatsStr(curClassLabelPair,curCls);
    %     [label,score,cost] = predict(curCls,curFeats');
    %     clsFeat(iClassifier,:) =
end
end

%% Important note - no way to get back to an "original" cell!
function [feats,labels] = selectSamples(featsAll,indsAll,cellAnnotations,uniqueLabels,curClassLabelPair)
annot1 = curClassLabelPair{1};
annot2 = curClassLabelPair{2};

feats1 = getFeats(featsAll,indsAll,cellAnnotations,uniqueLabels,annot1,annot2);
feats2 = getFeats(featsAll,indsAll,cellAnnotations,uniqueLabels,annot2,annot1);

nFeats1 = size(feats1,2);
nFeats2 = size(feats2,2);

feats = [feats1,feats2];
labels = [1*ones(nFeats1,1);2*ones(nFeats2,1)];
end

%% inds - of cell annotations NOT features!!
function outFeats = getFeats(inFeats,inds,cellAnnotations,uniqueLabels,annot1,annot2)
outFeats = [];

for i = 1:length(inds)
    curFeat = inFeats(:,i);
    curAnnot = cellAnnotations{inds(i)};
    if strcmpi(annot1{1},'REST')
        annot1 = getRestLabels(annot2,uniqueLabels);
    end
    if strcmpi(annot2{1},'REST')
        annot2 = getRestLabels(annot1,uniqueLabels);
    end
    
    for ia = 1 : length(curAnnot)
        if sum(strcmpi(curAnnot{ia},annot1)) && ~sum(strcmpi(curAnnot{ia},annot2))
            outFeats = [outFeats,curFeat];
        end
    end    
end

end


%%
function outLabels = getRestLabels(curLabels,uniqueLabels)
outLabels = {};
nOutLabels = 0;
for il = 1 : length(uniqueLabels)
    if sum(strcmpi(uniqueLabels{il},curLabels)) == 0
       nOutLabels = nOutLabels + 1;
       outLabels{nOutLabels} = uniqueLabels{il};
    end
end
end

%%
function outStr = getClsStr(curClassLabelPair)
outStr = '';
labels1 = curClassLabelPair{1};
outStr = [outStr labels1{1}];
for i = 2 : length(labels1)
    outStr = [outStr '|' labels1{i}];
end
outStr = [outStr '_VS_'];
labels2 = curClassLabelPair{2};
outStr = [outStr labels2{1}];
for i = 2 : length(labels2)
    outStr = [outStr '|' labels2{i}];
end
end

%%
function outStatsStr = getClsStatsStr(curClassLabelPair,curCls)
outStatsStr = getClsStr(curClassLabelPair);

resuberror = resubLoss(curCls);
% nErrors = resuberror * curCls.NumObservations;
R = confusionmat(curCls.Y,resubPredict(curCls));
nErrors = R(1,2)+R(2,1);

outStatsStr = sprintf('%s: %d/%d, confMat = %s\n',outStatsStr, nErrors,curCls.NumObservations,mat2str(R));
end

function [meanVals,stdVals] = getNormFeats(featsAll)
meanVals = mean(featsAll,2);
stdVals = std(featsAll,0,2);
end

function [featsNorm] = setNormFeats(feats,meanVals,stdVals)
meanMat = repmat(meanVals,[1,size(feats,2)]);
stdMat = repmat(stdVals,[1,size(feats,2)]);
featsNorm = (feats - meanMat)./ stdMat;
end

% Square matrix, where Cost(i,j) is the cost of classifying a point into class j if its true class is i 
% (i.e., the rows correspond to the true class and the columns correspond to the predicted class). 
% To specify the class order for the corresponding rows and columns of Cost, additionally specify 
% the ClassNames name-value pair argument.
function costVal = getCostVal(n1,n2)
n = n1 + n2;
costVal = [...
    [0,         1-n1/n];
    [1-n2/n,    0];
    ];
end

function [] = writeClsLog(clsAllLog,logFname,fopenMode)
logger = fopen(logFname,fopenMode);
for i = 1 : length(clsAllLog)
    fprintf(logger,clsAllLog{i});
end
fclose(logger);
end