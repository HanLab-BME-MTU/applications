function h = plotLcurve(M,sol_mats,u_M,forceMesh,varargin)
% plotLcurve calculate the L-curve and display it from a force field
%
% INPUT:
% M         : M is either the fwd Map, or a force field contain all
%             information needed for the remaining inputs except factor.
%             The L-curve will be plot ONLY FOR THE FIRST FRAME. Execute
%             for e.g. plotLcurve(forceField(5)) to plot it for the 5th
%             frame.
% sol_mats  : structure that contains the matrices that are need to
%             reconstruct the solutions. sol_mats has to be in the form
%             that is understood by the function calcSolFromSolMatsFastBEM.
% u_M       : displacement information for which M has been build up.
% forceMesh : contains the force mesh for which M has been calculated.
% factor    : (optional)the refinement factortor. The higher factor the 
%             finer the plot will be.
% wtBar     : (optional param/value) the handle to an existing waitbar
%
% Output:
% h         : the handle to the figure containing the L-curve

% display('This is correct only for meshes with a single basis class!');
% display('In the general case one has to substitute: f_rec=sol_coef * vol');

% Achim Besser, Dec 2010
% Sebastien Besson, Sep 2011

% Dispatch input if using the structure form of the force field
if isstruct(M)
    par=M(1).par;
    h= plotLcurve(par.M,par.sol_mats,par.u_M,par.forceMesh,varargin);
    return;
end

% Input check
ip= inputParser;
ip.addRequired('M',@isnumeric);
ip.addRequired('sol_mats',@isstruct);
ip.addRequired('u_M',@isnumeric);
ip.addRequired('forceMesh',@isstruct);
ip.addOptional('factor',10,@isscalar);
ip.addParamValue('wtBar',-1,@isscalar);
ip.parse(M,sol_mats,u_M,forceMesh,varargin{:})
factor=ip.Results.factor;
wtBar=ip.Results.wtBar;

% Initiate regularization parameter range
lowerLim=-15;
upperLim=0;
numPoints=factor*(upperLim-lowerLim)+1;
L=logspace(lowerLim,upperLim,numPoints);
L=[0 L Inf];

% Initialize output
residuals_u=zeros(numPoints,1);
norm_f=zeros(numPoints,1);


% Create waitbar if applicable (waitbar delegation or graphic session)
logMsg = 'Please wait, calculating L-curve';
timeMsg = @(t) ['\nEstimated time remaining: ' num2str(round(t/60)) 'min'];
tic;
if ishandle(wtBar),
    waitbar(0,wtBar,logMsg);
elseif feature('ShowFigureWindows')
    wtBar = waitbar(0,logMsg);
end

for j=1:length(L)
    textMess=['Calculate: ',num2str(numel(L)),' values for regularization parameter'];
    progressText(j/numel(L),textMess);
    
    regParam=L(j);
    [~,~,sol_coef]=calcSolFromSolMatsFastBEM(M,sol_mats,u_M,forceMesh,regParam,[],[]);
    u_rec=M*sol_coef;
    
    % basis functions with a larger support have to be weighted more!
    [normWeights]=getNormWeights(forceMesh);
    eyeWeights =diag(normWeights);    
    f_rec=eyeWeights*sol_coef;

    residuals_u(j)=sum((u_M-u_rec).^2);
    norm_f(j)=sum((f_rec).^2);
    
    if mod(j,5)==1 && ishandle(wtBar)
        tj=toc;
        waitbar(j/numel(L),wtBar,sprintf([logMsg timeMsg(tj*numel(L)/j-tj)]));
    end
    
end

% Close waitbar if generated by the function
if ishandle(wtBar) && ~ishandle(ip.Results.wtBar)
    close(wtBar);
end

% Plot figure
h=figure();
plot(log(residuals_u),log(norm_f),'r')
hold on
plot(log(residuals_u(2:factor:end-1)),log(norm_f(2:factor:end-1)),'.k')
for k=2:factor:length(L)-1
    text(log(residuals_u(k)),log(norm_f(k)),num2str(L(k)))
end
% plot extremal values:
plot(log(residuals_u(1)),log(norm_f(1)),'xr')
text(log(residuals_u(1)),log(norm_f(1)),num2str(L(1)))
plot(log([residuals_u(end) residuals_u(end)]),[min(log(norm_f(1:end-1))) max(log(norm_f(1:end-1)))],'--r')
text(log(residuals_u(end)),mean(log(norm_f(1:end-1))),num2str(L(end)))
xlabel('log|u_{data}-u_{model}|^2')
ylabel('log|f|^2')
hold off
title('L-curve')