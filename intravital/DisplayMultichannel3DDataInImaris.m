function [ varargout ] = DisplayMultichannel3DDataInImaris( im, varargin )
% Displays a multi-channel 3D volume in imaris 
% 
%   DisplayMultichannel3DDataInImaris(im, varargin)
%   [imarisAppHandle] = DisplayMultichannel3DDataInImaris(im, varargin)
% 
%   Input:
% 
%       Required Input Arguments:
% 
%           im - a single volume or a cell array containing various channels
% 
%       Optional Input Arguments (should be specified as param-value pairs)
% 
%           displayColors - allows you to specify the RGB color of each channel
% 
%               should be an (numChannels x 3) matrix where numChannels is the number
%               of channels provided. If you dont specify this, colors will be 
%               assigned internally.            
% 
%           spacing - voxel size/spacing of the volume
% 
%   Output:
% 
%       imarisAppHandle (optional) -- handle to imaris application
%                                     you can use this to close/delete/destroy 
%                                     the imaris instance generated by this
%                                     function call.
% 
%   Author: Deepak Roy Chittajallu (Created on Dec 6th 2012)
% 
% 

    % default color map -- only 6 channels are defined
    % if more than 6 channels then user should specify the displayColors 
    cMap(1,:) = [1 0 0];
    cMap(2,:) = [0 1 0];
    cMap(3,:) = [0 0 1];
    cMap(4,:) = [1 0 1];
    cMap(5,:) = [0 1 1];
    cMap(6,:) = [1 1 0];
    
    % get and validate input image argument
    p = inputParser;
    p.CaseSensitive = false;
    p.addRequired( 'im', @(x) (iscell(x) || (isnumeric(x) && ndims(x) == 3)) );
    p.parse( im );

    if isnumeric(p.Results.im) 
        im = {p.Results.im};
    else
        im = p.Results.im;
    end
    
    volSize = size(im{1});
    volSize(3) = size(im{1}, 3);
    numChannels = numel(im);

    default_displayranges = zeros(numChannels,2);
    for i = 1:numChannels
       curChannelVolSize = size(im{i});
       curChannelVolSize(3) = size(im{i}, 3);
       if ~isempty( setxor( curChannelVolSize, volSize ) )
          error('Images corresponding to all channels must of the same size and dimension'); 
       end
       default_displayranges(i,:) = double([ min(im{i}(:)) max(im{i}(:))]);
    end
    
    % get and validate other optional input arguments if provided
    p.addParamValue( 'spacing', ones(1,3), @(x) (isnumeric(x) && numel(x) == 3) );
    p.addParamValue( 'displayColors', cMap(1:numChannels,:), @(x) ( isnumeric(x) && ndims(x) == 2 && size(x,2) == 3 && size(x,1) == numChannels ) );
    p.addParamValue( 'displayRanges', default_displayranges, @(x) ( isnumeric(x) && ndims(x) == 2 && size(x,2) == 2 && size(x,1) == numChannels ) );
    p.addParamValue( 'spotLocations', [], @(x) (isnumeric(x) && ndims(x) == 2 && size(x,2) == 3) );
    p.addParamValue( 'spotColor', [1, 0, 0], @(x) (isnumeric(x) && numel(x) == 3) );
    p.addParamValue( 'spotRadius', 3, @(x) (isnumeric(x) && isscalar(x)) );
    p.addParamValue( 'surfaceObjects', [], @(x) (iscell(x) || isstruct(x)) );
    p.parse( im, varargin{:} );
    
    spacing = p.Results.spacing;
    displayColors = p.Results.displayColors;
    displayRanges = p.Results.displayRanges;
    spotLocations = p.Results.spotLocations;
    spotColor = p.Results.spotColor;
    spotRadius = p.Results.spotRadius;
    surfaceObjects = p.Results.surfaceObjects;
    
    % initialization
    imarisApp = imarisStartNew(nargout==0);
    imarisScene = imarisApp.mFactory.CreateDataContainer;
    imarisApp.mSurpassScene = imarisScene;
    imarisScene.AddChild(imarisApp.mFactory.CreateLightSource); %add the light to the scene
    imarisScene.AddChild(imarisApp.mFactory.CreateFrame); %add the frame to the scene    
    
    volSize = size( im{1} );
    volData = imarisApp.mFactory.CreateDataSet;
    volData.Create( 'eTypeUint16', volSize(2), volSize(1),  volSize(3), numChannels, 1);
    
    volData.mExtendMinX = 0;
    volData.mExtendMinY = 0;
    volData.mExtendMinZ = 0;
    volData.mExtendMaxX = volData.mSizeX * spacing(1);
    volData.mExtendMaxY = volData.mSizeY * spacing(2);
    volData.mExtendMaxZ = volData.mSizeZ * spacing(3);
    volData.mUnit = 'um';    
    
    for i = 1:numChannels 
    
        volData.SetDataVolume( uint16( permute(flipdim(im{i}, 1), [2,1,3]) ), i-1, 0);        
        volData.SetChannelColor( i-1, displayColors(i,1), displayColors(i,2), displayColors(i,3), 0.8 );
        volData.SetChannelRange( i-1, displayRanges(i,1), displayRanges(i,2) );
        
    end
    
    imarisApp.mDataSet = volData;
    imarisApp.mSurpassCamera.Fit;
    
    %Strangely enough, this is both necessary and sufficient to display the mDataSet in the newly created scene.
    imarisScene.AddChild(imarisApp.mFactory.CreateVolume);
    
    % add spots
    if ~isempty(spotLocations)
        
        numSpots = size(spotLocations, 1);
        
        spotLocations(:,2) = volSize(1) - spotLocations(:,2) + 1; % flip-y
        spotLocationsPhysp = (spotLocations - 1) .* repmat(spacing([2,1,3]), [numSpots, 1] );        
        spotRadii = ones(numSpots, 1) * spotRadius * spacing(1);
        spotTimes = zeros(numSpots,1);

        imarisSpots = imarisApp.mFactory.CreateSpots;
        imarisSpots.SetColor(spotColor(1), spotColor(2), spotColor(3), 0 );
        imarisSpots.Set(spotLocationsPhysp, spotTimes, spotRadii);                
        imarisApp.mSurpassScene.AddChild(imarisSpots);
                
    end
    
    % add surfaces
    if ~isempty( surfaceObjects )
       
        if isstruct( surfaceObjects )
            surfaceObjects = { surfaceObjects };
        end
        
        for obid = 1:numel(surfaceObjects)
            
            if ~isstruct(surfaceObjects{obid}) || ~isfield(surfaceObjects{obid}, 'surfaces')
                error( 'ERROR: each surface object must be a structure/structure-array contain a field surfaces specifying the geometry (vertices, faces, normals) for each surface belonging to the surface object' );
            end
            
            if isempty(surfaceObjects{obid}.surfaces)
                continue;
            end
            
            if sum(isfield( surfaceObjects{obid}.surfaces, {'vertices', 'faces', 'normals'})) ~= 3
                error( 'ERROR: each surface belonging to a suface object must contain must contain three fields -- vertices, faces, normals --- which degine the geometry of the surface' );
            end
                        
            curImarisSurfaceObject = imarisApp.mFactory.CreateSurfaces;
            
            % set name
            if isfield( surfaceObjects{obid}, 'name' )
                curImarisSurfaceObject.mName = surfaceObjects{obid}.name;
            end
            
            % set color
            if isfield( surfaceObjects{obid}, 'color' )
                if numel( surfaceObjects{obid}.color ) <= 3
                    surfaceObjects{obid}.color(4) = 0.0;
                end
                curImarisSurfaceObject.SetColor( surfaceObjects{obid}.color(1), ...
                                                 surfaceObjects{obid}.color(2), ...
                                                 surfaceObjects{obid}.color(3), ...
                                                 surfaceObjects{obid}.color(4) );
            end
           
            for sid = 1:numel( surfaceObjects{obid}.surfaces )

                curSurface = surfaceObjects{obid}.surfaces(sid);
                
                % flip y-dim of vertices
                curSurface.vertices(:,2) = volSize(1) - curSurface.vertices(:,2) + 1;

                % convert vertex coordinates to physical space
                curSurface.vertices = (curSurface.vertices - 1) .* repmat(spacing([2,1,3]), [size(curSurface.vertices,1), 1] );        

                % convert face indices to 0-based index
                curSurface.faces = curSurface.faces - 1;
           
                % time index
                if ~isfield( curSurface, 'timeIndex' )
                    curSurface.timeIndex = 0;
                end
                
                % add surface
                curImarisSurfaceObject.AddSurface( curSurface.vertices, ...
                                                   curSurface.faces, ...
                                                   curSurface.normals, ...
                                                   curSurface.timeIndex );
                
            end
            
            imarisApp.mSurpassScene.AddChild(curImarisSurfaceObject);
            
        end
        
    end
        
    % return imaris app object if requested
    if nargout >= 1
        varargout{1} = imarisApp;
    end
    
end
