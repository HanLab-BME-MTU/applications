function SCORE=fsmKinSaveScoreLists(speckleArray,fsmParam)
% fsmKinSaveScoreLists saves all calculated scores to disk for future use
% 
% fsmKinSaveScoreLists returns a single (n x 4) matrix containing all scores
%    over all time points and also saves n files "kinScore###.mat" containing
%    the scores for the n frames
%
% SYNOPSIS   SCORE=fsmKinSaveScoreLists(speckleArray,fsmParam)
%
% INPUT      speckleArray : reduced speckle structure
%                           (note - only the necessary fields are passed to avoid
%                           memory waste)
%            fsmParam     : general parameter structure
%
% OUTPUT     SCORE        : scores rearranged into a matrix with the form
%                           [t y x s]n     t : time point (frame)
%                                          y : y coordinate of the event position
%                                          x : x coordinate of the event position
%                                          s : score
%                                          n : total number of events
%
% REMARK : SCORE does not contain the scores generated by the temporal low-pass filtering!

if nargin~=2
    error('Two parameters are expected');
end

% Set a constant (this was needed when the grid was placed on the images
%    (still maintained for future use)
yxOffset=[0 0];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% READ NEEDED PARAMETERS FROM fsmParam
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
userPath=fsmParam.main.path;
n=fsmParam.specific.imageNumber;
strg=fsmParam.specific.formString;
firstIndex=fsmParam.specific.firstIndex;
lastIndex=fsmParam.specific.lastIndex;

% Change to user directory
oldDir=cd;
cd(userPath);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% REARRANGING SCORES INTO A SCORE LIST
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Preallocate memory for SCORE
nRows=length(find([speckleArray.activity]~=0));
SCORE=zeros(nRows,4);

% Initializing progress bar
h = waitbar(0,'Rearranging speckles...');

% Run through speckleArray and place events
l=length([speckleArray.timepoint]);

% Calculate some longer step size (not to spend too much time updating the waitbar)
step=0.5*10^fix(log10(l)-1); if step<1, step=1; end

counter=0;
for i=1:l
	if speckleArray.activity(i)~=0
		counter=counter+1;
        if speckleArray.status(i)=='b'
            eventTimePoint=double(speckleArray.timepoint(i))+1;
        elseif speckleArray.status(i)=='d'
            eventTimePoint=double(speckleArray.timepoint(i))-1;
        else
            error('This event has an activity but is not a ''b'' or ''d'' speckle');
        end
        SCORE(counter,1:4)=...
            [eventTimePoint double(speckleArray.spPos(i,1)) double(speckleArray.spPos(i,2))  speckleArray.score(i)];
	end

    % Update waitbar if needed
    if step>1
        if mod(i,step)==1
            waitbar(i/l,h);
        end
    else
        waitbar(i/l,h);
    end        
    
end

% Close waitbar
close(h);

% Sort for timepoint
SCORE=sortrows(SCORE,1:4);

% Add yxOffset to the positions
SCORE(:,2)=SCORE(:,2)+yxOffset(1);
SCORE(:,3)=SCORE(:,3)+yxOffset(2);

% Saving SCORE
save SCORE.mat SCORE;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% SAVING INDIVIDUAL SCORE LISTS
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

h = waitbar(0,'Saving score lists...');

% Go through all timepoints
for i=2:n-1 % The first and last frames do not have scores assigned
	
    % Index of the current image
    currentIndex=i+firstIndex-1;
    
    % Extract information for frame i
    indx=find(SCORE(:,1)==i);
    
    % Save info to disk
    indxStr=sprintf(strg,currentIndex);   
    
    % Load black-and-white mask
    if ~isempty(indx)
        evalStr=['kinScore',indxStr,'=SCORE(indx,:);save ',userPath,filesep,'kinScore',filesep,'kinScore',indxStr,'.mat kinScore',indxStr,';'];
        eval(evalStr);
    else
        evalStr=['kinScore',indxStr,'=[',num2str(i),' 0 0 0];save ',userPath,filesep,'kinScore',filesep,'kinScore',indxStr,'.mat kinScore',indxStr,';'];
        eval(evalStr);
    end
    
    % Update waitbar
    waitbar((i-1)/n,h);
end

% Save also first ald last (empty) score lists
indxStr=sprintf(strg,firstIndex);   
evalStr=['kinScore',indxStr,'=[1 0 0 0]; SCORE(indx,:);save ',userPath,filesep,'kinScore',filesep,'kinScore',indxStr,'.mat kinScore',indxStr,';'];
eval(evalStr);
% Update waitbar
waitbar(i/n,h);
%
indxStr=sprintf(strg,lastIndex);   
evalStr=['kinScore',indxStr,'=[',num2str(n),' 0 0 0]; SCORE(indx,:);save ',userPath,filesep,'kinScore',filesep,'kinScore',indxStr,'.mat kinScore',indxStr,';'];
eval(evalStr);
% Update waitbar
waitbar((i+1)/n,h);
% Close waitbar
close(h);

% Back to old directory
cd(oldDir);
