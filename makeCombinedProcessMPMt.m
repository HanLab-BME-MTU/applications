function [mpm_total] = makeCombinedProcessMPMt(imagesize, numf, plotOn ,varargin);
% make simulated MPM (with specified number of frames and imagesize) as a
% superposition of clustered and random processes
% INPUT:
% imagesize     image size, in format [sx,sy]
% numf          number of frames
% varargin      variable number of inputs; each input is a vector that
%               specifies a process; all vectors have the form
%               [ type   density    other descriptors ]
%               the individual descriptors are as follows
%       IF type = 1     random process
%                       density = point density per frame
%       IF type = 2     Cox cluster process (points are distributed
%                       with Gaussian intensity profile around parent)
%                       density = density of parent points per frame,
%                       additional descriptors for this process are
%                       lambda = average number of children per parent
%                       NOTE that child initiation around the parent is a
%                       Poisson process!!
%                       sigma = sigma of Gaussian distance distribution of
%                       children around parent
%                       sigmaDiff (optional) = sigma of random frame-to-
%                       frame displacement of parents (default =0)
%       IF type = 3     Matern cluster process (points are distributed
%                       randomly in a disc around parent)
%                       other parameters: as in Cox cluster, sigma here is
%                       the radius of the disc
%       IF type = 4     inclusion process: the points generated by the
%                       processes above are restricted to the area INSIDE
%                       randomly distributed discs
%                       density = density of disc centers
%                       radius_raft = radius of discs
%                       sigmaDiff = sigma of disc diffusion
%       IF type = 5     exclusion process: the points generated by the
%                       processes above are restricted to the area OUTSIDE
%                       randomly distributed discs
%                       Parameters as for type=4
%
% Example:
% [mpm_total] = makeCombinedProcessMPMt([400 400], 300, [1 0.0002], [2 0.002 0.1 3 0.5]);
% creates a distribution that's a superposition of
% A: a random distribution with 0.0002*(400^2)=32 objects per frame, plus
% B: a Cox-clustered distribution with 320 parents, which move 0.5*randn pix
% per frame, where each parent has poissrnd(0.1) children, distributed with
% sigma=3 pix around the parent
%
% last modified: Dinah Loerke, July 1, 2009


sx = imagesize(1);
sy = imagesize(2);
imarea = sx*sy;

% loop over processes, read process types
for i=1:length(varargin)
    vec = varargin{i};
    proc(i) = vec(1);
end
% processes with numbers 1-3 are point-generating processes, whereas
% numbers 4-5 are point-restricting (or excluding) processes
pos_generate = find(proc<=3);
pos_restrict = find(proc>3);


% loop over the desired number of processes
if length(pos_generate)==0
    error('no point-generating processes specified');
else
    % loop over all point-generating processes
    for i=1:length(pos_generate)

        % current generating parameters
        cvec = varargin{pos_generate(i)};

        % first position: distribution type
        vi_type = cvec(1);
        % second position: intensity of the process (number of points or
        % parents
        vi_int = cvec(2);

        switch vi_type
            % distribution is random
            case 1
                % number of points is intensity times area
                nump = vi_int * imarea;

                % generate random distribution
                x_rand = 1+(sx-1)*rand(nump,numf);
                y_rand = 1+(sy-1)*rand(nump,numf);

                generatedPoints(i).type = 1;
                generatedPoints(i).mpm = zeros(nump,2*numf);
                generatedPoints(i).mpm(1:nump,1:2:end)  = x_rand;
                generatedPoints(i).mpm(1:nump,2:2:end)  = y_rand;

                % distribution is cluster (of raft or Cox type)
            case { 2, 3}

                % third value is number of daughters per mother
                nump_lambda = cvec(3);
                % fourth value is sigma of distribution (in pixel)
                sigma_cluster = cvec(4);
                % fifth value (optional) is sigma of parent diffusion (also
                % in pixel)
                if length(cvec)>4
                    sigma_diff = cvec(5);
                else
                    sigma_diff = 0;
                end

                if length(cvec)>5
                    parentMinDistance = cvec(6);
                else
                    parentMinDistance = 0;
                end

                % in the first frame, define the positions of the parent
                % points; in subsequent frames, re-use the original parent
                % positions or let them diffuse as specified
                % NOTE: to avoid edge effects, parent points have to be
                % simulated outside of the image, too
                sxLarge = sx+20;
                syLarge = sy+20;
                imareaLarge = sxLarge*syLarge;
                % number of points is intensity times area
                nump = vi_int * imareaLarge;

                % generate random distribution of mothers, in area with
                % a buffer of +10 on all sides of the image
                x_mother = 1+(sxLarge-1)*rand(nump,1) - 10;
                y_mother = 1+(syLarge-1)*rand(nump,1) - 10;
                mpm_mother_start = [x_mother y_mother];

                %calculate interparent distance
                parentDistance = squareform(pdist(mpm_mother_start));
                %replace zeros with nans
                parentDistance(parentDistance == 0) = nan;
                %if any of these distances are smaller than minimum
                %specified parent distance then redraw those
                %only allow this to loop for so long
                loopcount = 0;
                while any(min(parentDistance,[],2) < parentMinDistance) || loopcount == 50
                    findParent = find(min(parentDistance,[],2) < parentMinDistance);
                    x_redraw = 1+(sxLarge-1)*rand(length(findParent),1) - 10;
                    y_redraw = 1+(syLarge-1)*rand(length(findParent),1) - 10;
                    mpm_mother_start(findParent,:) = [x_redraw y_redraw];
                    loopcount = loopcount + 1;
                    %calculate interparent distance
                    parentDistance = squareform(pdist(mpm_mother_start));
                    %replace zeros with nans
                    parentDistance(parentDistance == 0) = nan;%calculate interparent distance
                end

                mpm_mother = [];
                mpm_mother(:,1:2) = mpm_mother_start;
                % fill subsequent time positions
                for t=1:numf
                    if t==1
                        mpm_mother_curr = mpm_mother_start;
                    else
                        mpm_mother_prev = mpm_mother(:,2*t-3:2*t-2);
                        mpm_mother_curr = mpm_mother_prev + sigma_diff*randn(size(mpm_mother_prev,1),2);
                    end
                    mpm_mother(:,2*t-1:2*t) = mpm_mother_curr;

                    % generate daughters
                    if vi_type==2
                        mpm_daughters_curr = makeCoxProcessMPM(mpm_mother_curr,nump_lambda,sigma_cluster,imagesize);
                    else
                        mpm_daughters_curr = makeRaftProcessMPM(mpm_mother_curr,nump_lambda,sigma_cluster,imagesize);
                    end
                    [ndx,ndy] = size(mpm_daughters_curr);
                    mpm_daughters(1:ndx,2*t-1:2*t) = mpm_daughters_curr;
                    if any(mpm_daughters(:,1:2:end)) > 120
                        keyboard
                    end
                end

                generatedPoints(i).type = vi_type;
                generatedPoints(i).mpm  = mpm_daughters;
                generatedPoints(i).mpm_parents  = mpm_mother;

        end % of switch/case

    end % of for i-loop

end % of if



%% collect all generated points

mpm_total = nan*zeros(1,2*numf);

for i=1:length(generatedPoints)
    mpm = generatedPoints(i).mpm;
    mpm_total = [mpm_total; mpm];
end
mpm_total(1,:) = [];


%% now loop over all restricting processes
if length(pos_restrict)==0
    disp('no point-restricting processes specified');
else
    % loop over all point-restricting processes
    for i=1:length(pos_restrict)

        % current generating parameters
        cvec = varargin{pos_restrict(i)};

        % first position: distribution type
        vi_type = cvec(1);
        % second position: intensity of the process (number of points or
        % parents
        vi_int = cvec(2);

        switch vi_type
            % distribution is raft-shaped inclusion or exclusion, i.e. a
            % restriction of previous data rather than added new data
            case {4,5}

                % third value is radius of disc (in pixel)
                radius_raft = cvec(3);

                % fourth value (optional) is sigma of raft diffusion (also
                % in pixel)
                if length(cvec)>3
                    sigma_diff = cvec(4);
                else
                    sigma_diff = 0;
                end

                % in the first frame, define the positions of the raft
                % points; in subsequent frames, re-use the original raft
                % positions or let them diffuse as specified
                % NOTE: to avoid edge effects, rafts have to be
                % simulated outside of the image, too
                sxLarge = sx+20;
                syLarge = sy+20;
                imareaLarge = sxLarge*syLarge;
                % number of points is intensity times area
                nump = vi_int * imareaLarge;

                % generate random distribution of rafts, in area with
                % a buffer of +10 on all sides of the image
                x_raft = 1+(sxLarge-1)*rand(nump,1) - 10;
                y_raft = 1+(syLarge-1)*rand(nump,1) - 10;
                mpm_raft_start = [x_raft y_raft];
                mpm_raft = [];
                mpm_raft(:,1:2) = mpm_raft_start;

                % fill subsequent time positions
                for t=1:numf
                    if t==1
                        mpm_raft_curr = mpm_raft_start;
                    else
                        mpm_raft_prev = mpm_raft(:,2*t-3:2*t-2);
                        mpm_raft_curr = mpm_raft_prev + sigma_diff*randn(size(mpm_raft_prev,1),2);
                    end
                    mpm_raft(:,2*t-1:2*t) = mpm_raft_curr;

                    mpm_ref = mpm_raft_curr;
                    mpm_pt = mpm_total(:,2*t-1:2*t);
                    mpm_pt_use = mpm_pt(find(min(mpm_pt,[],2)>0),:);

                    % determine distances of all daughter points from the central point
                    dm = distMat2(mpm_pt_use,mpm_ref);
                    dm_min = min(dm,[],2);

                    % inclusive: use points that are within radius from rafts
                    if vi_type==4
                        fpos_stat = find(dm_min<=radius_raft);

                        % exclusive: use points that are beyond radius from
                        % rafts
                    else
                        fpos_stat = find(dm_min>radius_raft);

                    end

                    mpm_use_restrict = mpm_pt_use(fpos_stat,:);
                    [nux,nuy] = size(mpm_use_restrict);
                    mpm_total(:,2*t-1:2*t) = 0;
                    mpm_total(1:nux,2*t-1:2*t) = mpm_use_restrict;

                end

                if vi_type==4
                    generatedPoints_restrictions(i).type = [ 4, radius_raft];
                else
                    generatedPoints_restrictions(i).type = [ 5, radius_raft];
                end

                generatedPoints_restrictions(i).mpm = mpm_total;
                generatedPoints_restrictions(i).mpm_restrict = mpm_raft;

            otherwise

                error('unknown process identification number');
        end % of case/switch

    end % of for i-loop

end % of if



%% plot results
if plotOn
    figure

    for t=1:numf
        for p=1:length(pos_generate)
            ct = generatedPoints(p).type;
            cmpm = generatedPoints(p).mpm;
            if ct==1
                plot(cmpm(:,2*t-1),cmpm(:,2*t),'b.'); hold on
            else
                cmpm_moth = generatedPoints(p).mpm_parents;
                plot(cmpm(:,2*t-1),cmpm(:,2*t),'g.'); hold on;
                plot(cmpm_moth(:,2*t-1),cmpm_moth(:,2*t),'cx');
            end
        end

        for p=1:length(pos_restrict)
            ct = generatedPoints_restrictions(p).type;
            cmpm = generatedPoints_restrictions(p).mpm;
            cmpm_res = generatedPoints_restrictions(p).mpm_restrict;

            plot(cmpm_res(:,2*t-1),cmpm_res(:,2*t),'mx');
        end

        plot(mpm_total(:,2*t-1),mpm_total(:,2*t),'ro'); hold off;
        axis([1 sx 1 sy]);
        pause(0.1);

    end
end %of if plot is on


end % of function



%%       ==================================================================

function [mask] = makeMaskFromMPM(mpm,radius, imagesize);

xs = imagesize(1);
ys = imagesize(2);
mask = zeros(xs,ys);

% positions of mini-window in grid form
[miniImX, miniImY] = ndgrid(-radius:radius,-radius:radius);
miniDist = sqrt(miniImX.^2 + miniImY.^2);
% extract from the square grid positions those below the specified radius
% (convert to circular area)
[XinPix, YinPix] = find(miniDist<=(radius));
XinPix = XinPix-(radius+1);
YinPix = YinPix-(radius+1);
% now XinPix and YinPix contain the positions of the pixels in the circular
% area around the origin with radius radius

% figure;

for n=1:size(mpm,1)

    CurrCoorXCon = round(mpm(n,2))+XinPix;
    CurrCoorYCon = round(mpm(n,1))+YinPix;
    % bad posititons = those outside the image
    goodPos = find( (CurrCoorXCon>=1) & (CurrCoorYCon>=1) & (CurrCoorXCon<=xs) & (CurrCoorYCon<=ys) );

    subIndGoodPosCon = sub2ind([xs ys],CurrCoorXCon(goodPos),CurrCoorYCon(goodPos));

    mask(subIndGoodPosCon) = 1;

    %     hold off;
    %     imshow(mask);
    %     hold on;
    %     plot(mpm(1:n,1),mpm(1:n,2),'rx');

end


end % of subfunction



%%       ==================================================================


function [mpm_daughters] = makeCoxProcessMPM(mpm_mothers,lambda_Poisson,sigma,imagesize);


sx = imagesize(1);
sy = imagesize(2);

nmp = size(mpm_mothers,1);
nms = (size(mpm_mothers,2)/2);

% NOTE: the mother points can lie outside the specified image size (in
% simulations, this can be necessary to avoid edge effects) - in any case,
% the daughter points are only retained if they come to lie inside the
% image


% in a cox process, the number of daughters per mother is
% poisson-distributed
vec_nump = poissrnd(lambda_Poisson,nmp,1);


% loop over number of samples
for s=1:nms

    % initialize daughter points
    cmpm_daughters = zeros(1,2);

    %loop over all mother points
    for n=1:nmp

        % position of current mother cluster center
        centerpoint = mpm_mothers(n,2*s-1:2*s);
        % current number of daughters from poisson distribution
        numd = vec_nump(n);

        if numd>0

            %generate vector length of mother-daughter distance NOTE randn
            lenDis = sigma*randn(numd,1);

            %generate angle NOTE rand
            angle = 2*pi*rand(numd,1);

            %resulting endpoint for this daughter point
            endx = centerpoint(1) + lenDis .* sin(angle);
            endy = centerpoint(2) + lenDis .* cos(angle);

            cmpm = [endx endy];

            cmpm_daughters = [cmpm_daughters ; cmpm];
        end

    end

    px0 = (cmpm_daughters(:,1)>1);
    py0 = (cmpm_daughters(:,2)>1);
    pxi = (cmpm_daughters(:,1)<sx);
    pyi = (cmpm_daughters(:,2)<sy);

    fpos = find( px0 & py0 & pxi & pyi );

    cmpm_daughters = cmpm_daughters(fpos,:);
    [csx,csy] = size(cmpm_daughters);

    if s==1
        mpm_daughters = cmpm_daughters;
    else
        mpm_daughters((1:csx),((2*s-1):2*s)) = cmpm_daughters;
    end


end % of for s

end % of function



%%       ==================================================================

function [mpm_daughters] = makeRaftProcessMPM(mpm_mothers,lambda_Poisson,sigma,imagesize);


sx = imagesize(1);
sy = imagesize(2);

nmp = size(mpm_mothers,1);
nms = (size(mpm_mothers,2)/2);
%
% if length(num_mothers)==1
%     vec_nump = num_mothers+zeros(nmp,1);
% else
%     vec_nump = num_mothers;
% end


% the number of daughters per mother is poisson-distributed
vec_nump = poissrnd(lambda_Poisson,nmp,1);

% loop over number of samples
for s=1:nms

    %positions of mother cluster centers
    cmpm_daughters = zeros(1,2);


    %loop over all mother points
    for n=1:nmp

        centerpoint = mpm_mothers(n,2*s-1:2*s);
        numd = vec_nump(n);

        if numd>0

            %generate vector length of mother-daughter distance NOTE rand
            lenDis = sigma*rand(numd,1);

            %generate angle NOTE rand
            angle = 2*pi*rand(numd,1);

            %resulting endpoint for this daughter point
            endx = centerpoint(1) + lenDis .* sin(angle);
            endy = centerpoint(2) + lenDis .* cos(angle);

            cmpm = [endx endy];

            cmpm_daughters = [cmpm_daughters ; cmpm];
        end

    end

    px0 = (cmpm_daughters(:,1)>1);
    py0 = (cmpm_daughters(:,2)>1);
    pxi = (cmpm_daughters(:,1)<sx);
    pyi = (cmpm_daughters(:,2)<sy);

    fpos = find( px0 & py0 & pxi & pyi );

    cmpm_daughters = cmpm_daughters(fpos,:);
    [csx,csy] = size(cmpm_daughters);

    if s==1
        mpm_daughters = cmpm_daughters;
    else
        mpm_daughters((1:csx),((2*s-1):2*s)) = cmpm_daughters;
    end

end % of for s

end % of function
