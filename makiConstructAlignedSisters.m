function sisterList = makiConstructAlignedSisters(dataStruct,removeNetDisp,...
    randomize)
%MAKICONSTRUCTALIGNEDSISTERS extracts aligned coordinates of sister pairs
%
%SYNOPSIS sisterList = makiConstructAlignedSisters(dataStruct,removeNetDisp,...
%    randomize)
%
%INPUT  dataStruct: dataStruct as generated by makiMovieAnalysis. Must have
%                   all tasks (1-9, except 4) performed.
%       removeNetDisp: 1 - Make center of each sister pair at zero
%                      throughout the whole movie, 0 otherwise.
%                      Optional. Default: 0.
%       randomize: 1 - Randomize sister pairing, 0 otherwise.
%                  Optional. Default: 0.
%
%OUTPUT sisterList: Same as input (dataStruct.sisterList) but with
%                   additional fields (.coords1Aligned, .coords2Aligned 
%                   and .distanceAligned) that contain the aligned
%                   coordinates and distance, with whatever additional 
%                   modifications requested in the input.
%
%Khuloud Jaqaman, February 2008

%% input
if nargin < 2 || isempty(removeNetDisp)
    removeNetDisp = 0;
end

if nargin < 3 || isempty(randomize)
    randomize = 0;
end

%copy fields out of dataStruct
sisterList = dataStruct.sisterList;
tracks = dataStruct.tracks;
frameAlignment = dataStruct.frameAlignment;
initCoord = dataStruct.initCoord;

%get number of sisters
numSisters = length(sisterList);

%% get aligned coordinates

%go over all sisters
for iSister = 1 : numSisters

    %find track indices
    tracksIndx = sisterList(1).trackPairs(iSister,1:2);

    %determine frame where each track starts
    trackStart = [tracks(tracksIndx(1)).seqOfEvents(1,1) ...
        tracks(tracksIndx(2)).seqOfEvents(1,1)];

    %find number of frames and frames where pair "exists"
    goodFrames = ~isnan(sisterList(iSister).distances(:,1));
    numFrames = length(goodFrames);
    goodFrames = find(goodFrames);

    %find feature indices making up sisters
    sisterIndx1 = NaN(numFrames,1);
    sisterIndx2 = NaN(numFrames,1);
    sisterIndx1(goodFrames) = tracks(tracksIndx(1))...
        .tracksFeatIndxCG(goodFrames-trackStart(1)+1);
    sisterIndx2(goodFrames) = tracks(tracksIndx(2))...
        .tracksFeatIndxCG(goodFrames-trackStart(2)+1);

    %get aligned sister coordinates
    coords1 = NaN(numFrames,6);
    coords2 = NaN(numFrames,6);
    for iFrame = goodFrames'
        coords1(iFrame,:) = frameAlignment(iFrame).alignedCoord(sisterIndx1(iFrame),:);
        coords2(iFrame,:) = frameAlignment(iFrame).alignedCoord(sisterIndx2(iFrame),:);
    end

    %store aligned coordinates in sisterList
    sisterList(iSister).coords1Aligned = coords1;
    sisterList(iSister).coords2Aligned = coords2;
    sisterList(iSister).distanceAligned = sqrt(sum((coords1(:,1:3) - coords2(:,1:3)).^2,2));
    
end

%% remove net displacement

if removeNetDisp

    %go over all sisters
    for iSister = 1 : numSisters

        %get coordinates
        coords1T = sisterList(iSister).coords1Aligned;
        coords2T = sisterList(iSister).coords2Aligned;

        %calculate center of mass
        centerMass = (coords1T(:,1:3) + coords2T(:,1:3)) / 2;

        %shift coordinates such that center of mass is always at 0
        sisterList(iSister).coords1Aligned(:,1:3) = coords1T(:,1:3) - centerMass;
        sisterList(iSister).coords2Aligned(:,1:3) = coords2T(:,1:3) - centerMass;

    end

end

%% randomize kinetochore pairing

if randomize

    %first, list pairs such that sister 1 is the "left" kinetochore and
    %sister 2 is the "right" kinetochore
    for iSister = 1 : numSisters
        
        %calculate the average coordinate of each sister along the normal
        %to the metaphase plate
        meanCoord1Normal = nanmean(sisterList(iSister).coords1Aligned(:,1));
        meanCoord2Normal = nanmean(sisterList(iSister).coords2Aligned(:,1));
        
        %put the sister with the smaller average coordinate on the "left"
        %negative is smaller than positive, no matter the magnitude
        if meanCoord2Normal < meanCoord1Normal
            tmp = sisterList(1).trackPairs(iSister,1);
            sisterList(1).trackPairs(iSister,1) = sisterList(1).trackPairs(iSister,2);
            sisterList(1).trackPairs(iSister,2) = tmp;
            tmp = sisterList(iSister).coords1Aligned;
            sisterList(iSister).coords1Aligned = sisterList(iSister).coords2Aligned;
            sisterList(iSister).coords2Aligned = tmp;
        end
        
    end

    %     %second, shuffle the "right" sisters to make random pairs
    %     indxRand = randsample(numSisters,numSisters);
    %
    %     %store original sister list in a new variable
    %     sisterListOriginal = sisterList;
    %
    %     %go over all sisters
    %     for iSister = 1 : numSisters
    %
    %         %assign new "right" sister
    %         sisterList(1).trackPairs(iSister,2) = sisterListOriginal(1).trackPairs(indxRand(iSister),2);
    %
    %         %move corresponding coordinates
    %         sisterList(iSister).coords2Aligned = sisterListOriginal(indxRand(...
    %             iSister)).coords2Aligned;
    %
    %         %calculate new distance vector and store
    %         sisterList(iSister).distanceAligned = sqrt(sum((sisterList(...
    %             iSister).coords1Aligned(:,1:3) - sisterList(iSister...
    %             ).coords2Aligned(:,1:3)).^2,2));
    %
    %     end

    %second, shuffle sisters such that "left" kinetochores are paired and
    %"right" kinetochores are paired
    indx1Rand = randsample(numSisters,numSisters);
    indx2Rand = randsample(numSisters,numSisters);

    %if there is an odd number of sisters, remove the last
    if mod(numSisters,2)
        indx1Rand = indx1Rand(1:end-1);
        indx2Rand = indx2Rand(1:end-1);
        numSisters = numSisters - 1;
    end

    %store original sister list in a new variable
    sisterListOriginal = sisterList;

    %go over all sisters
    for iSister = 1 : numSisters/2

        %assign new sister pair
        sisterList(1).trackPairs(iSister,1) = sisterListOriginal(...
            1).trackPairs(indx1Rand(2*iSister-1),1);
        sisterList(1).trackPairs(iSister,2) = sisterListOriginal(...
            1).trackPairs(indx1Rand(2*iSister),1);

        %move corresponding coordinates
        sisterList(iSister).coords1Aligned = sisterListOriginal(indx1Rand(...
            2*iSister-1)).coords1Aligned;
        sisterList(iSister).coords2Aligned = sisterListOriginal(indx1Rand(...
            2*iSister)).coords1Aligned;

        %calculate new distance vector and store
        sisterList(iSister).distanceAligned = sqrt(sum((sisterList(...
            iSister).coords1Aligned(:,1:3) - sisterList(iSister...
            ).coords2Aligned(:,1:3)).^2,2));

    end
    for iSister = numSisters/2+1 : numSisters

        %assign new sister pair
        sisterList(1).trackPairs(iSister,1) = sisterListOriginal(...
            1).trackPairs(indx2Rand(2*(iSister-numSisters/2)-1),2);
        sisterList(1).trackPairs(iSister,2) = sisterListOriginal(...
            1).trackPairs(indx2Rand(2*(iSister-numSisters/2)),2);

        %move corresponding coordinates
        sisterList(iSister).coords1Aligned = sisterListOriginal(indx2Rand(...
            2*(iSister-numSisters/2)-1)).coords2Aligned;
        sisterList(iSister).coords2Aligned = sisterListOriginal(indx2Rand(...
            2*(iSister-numSisters/2))).coords2Aligned;

        %calculate new distance vector and store
        sisterList(iSister).distanceAligned = sqrt(sum((sisterList(...
            iSister).coords1Aligned(:,1:3) - sisterList(iSister...
            ).coords2Aligned(:,1:3)).^2,2));

    end

end

%% ~~~ the end ~~~