function [mf,mv,mnb1,mnb2,mdint1,mdint2,mfc,sfft] = ...
    clutchModelActinElasticityMichels(nm,fm1,nc,dint1,dint2,kont1,...
                            kont2,kof1,kof2,kc,ksub,konv,pt,mr,intadd,ion,...
                            dActin, tTotal,d,verbose,actinRate,eta,slip,L,NnMax)
% function [mf,mv,mnb1,mnb2,mdint1,mdint2] =
% clutchModelActinElasticity(nm,fm1,vu,nc,dint1,dint2,kont1,kont2,kof1,kof2,
%                            kc,ksub,konv,pt,mr,intadd,ion) 
% calculates the mean force on the substrate generated by a rearward
% flowing csk according to the model of Chan and Odde (Science, 2008). 
% In addition, this function considers 2 integrin populations with
% different kon and koff (Elosegui-Artola 2016). Furthermore, the actin
% flow in the model is now elasticity driven, and the kinematic interaction
% between actin and the clutch is no longer hard-wired from the velocity,
% but based on force equilibrium affected by elasticity of components
% including that of actin. - Sangyoon Han
% 
% Input Parameters of the model (default values from chan and odde listed):
%       nm      Number of myosin motors (= 75)
%       fm1     Stall force of 1 motor (N) (= -2e-12) 
%       vu      Unloaded myosin motor velocity (m/s) (= -120e-9)
%       nc      Number of molecular clutches (fibronectin molecules) (= 75)
%       dint1:  Density of integrin molecules, type 1 (integrins/um2).
%       dint2:  Density of integrin molecules, type 2 (integrins/um2).
%       kont1   True on-rate (um2/s), 1st integrin type (= 1) 
%       kont2   Same for 2nd integrin type
%       kof1    Koff for 1st integrin type (scaling factor with respect to data
%               from Kong et al JCB paper).
%       kof2    Same for 2nd integrin type.
%       kc      Clutch spring constant (we assume the same for both
%               integrins) (N/m) (= 5e-3)
%       ksub    Substrate spring constant (N/m) (= 0.1e-3; or
%               10.^([-2:0.1:2]).*1e-3)
%       konv    Binding rate between vinculin and unfolded talin
%       pt      Fraction of clutch force experienced by talin
%       rf      Threshold force that leads to reinforcement (addition of another
%               integrin)
%       mr      Maximum integrin density for each integrin
%       intadd  Number of integrins added per sq. micron every time reinforcement happens.
%       ion     mn or mg, to take corresponding koff data from kong et al JCB paper
%       v_actin Unloaded actin-polymerization-driven actin flow speed
%       dActin  Density of F-actin molecules (which can be low for
%               Arp2/3-inhibited actin and intermediate for
%               Formin-inhibited actin). (Need a reference, 300 for now for
%               control). This will also determine the elasticity of actin
%               by k_actin = dActin * k_basicActin where k_basicActin is
%               calibrated by a published article (?)
%       tTotal  Total time of simulation (default: 100 s)
%       d       Distance of the adhesion from cell membrane. This will determine how many
%               monomers are in-between. (m). Default: 2 um = 2e-6 m.
% 
% Output parameters
%       mf              Mean force on substrate (N)
%       mv              Mean rearward speed (m/s)
%       mnb1, mnb2:     Mean number of bound clutches for both integrins
%       mdint1, mdint2: Mean densities of both integrin types
% 
% Adapted from Roca-cusachs,
% Sangyoon Han, May 2022

%% Initialize variables:
if nargin<20
    tTotal = 100; % total time period
    d = 2e-6; % distance from edge to adhesion
elseif nargin<21
    d = 2e-6; % distance from edge to adhesion in m
end
% verbose = false; %1; 
verboseEach = false; %true; %false;
showSpeeds=false;
Fs = nm.*fm1; %Stall force of the system 
kB = 1.38064852e-23; %m2 kg s-2 K-1
T = 278; %K

% deltaActin = 2.7e-9; % m
c = 0.8; %c is a coefficient that accounts for geometrical effects: 0.13 is for sphere, maybe 1 for a flat edge. 
C_actin = kB*T*c*dActin; %constant for force-velocity relationship in actin: This is assumption for now 
R = 10e-6; % m, the radius of curvature of edge. Given normal cell, it can be ~ 10-30 um
Fs_actin = 5e-11; %C_actin/(4*R); %-C_actin/(4*R); % stall force for actin addition
% L = 2e-9; % m, the length of each actin monomer spring segment. 
Norg = d/L; % The number of actin springs in-between the membrane and adhesion
Nnew = 0; % Newly-added actin springs at the membrane in front of the adhesion
Nall = Norg + Nnew; % all new actin
%NnMax = 5; % max N_curnew

k_basicActin = 1e-6; % basic actin elasiticity: currently totally ambiguous.
k_actin = dActin * k_basicActin; % actin polymer elasticity
disp(['K Actin :: ' num2str(k_actin)])
a = 0.0001; %Adaptation factor for k_actin
pK = 0.6; %Max contraction limit: There should be an ultimate strain per spring.
pNnew = 1; %proportion of distance difference for space for new actin addition.
q = 0.1; % Max conpression limit of the spring

pot=0.05e-3;% From Etienne's model
k0=k_actin; % From Etienne's model
boundTime=0;
unboundTime=0;
Fa_last=0;


ts = 5e-3; % Time step used for calculation
xsub = 0; %Substrate displacement
prevXcMax = 0; %  clutch displacement in the previous step
bound = zeros(nc,1); % Binding status of each clutch (0 unbound, 1 1st integrin, 2 2nd integrin)
folding = zeros(nc,1); % Folding status of each clutch (0 folded, 1 unfolded, 2 vinculin-bound)
xc = zeros(nc,1); %displacement of each clutch
xc_prev = zeros(nc,1); %displacement of each clutch in previous time step
Fc = zeros(nc,1); % Force in each clutch
dint1i = dint1; %Density of integrin type 1 before reinforcement
dint2i = dint2; %Density of integrin type 2 before reinforcement
timeStepAll = 0:ts:tTotal;
nTimeSteps = numel(timeStepAll);
f = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
v = zeros(1,nTimeSteps);  %Rearward speed as a function of time
nb1 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 1
nb2 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 2
dint1t = zeros(1,nTimeSteps); % Density of integrin type 1 as a function of time
dint2t = zeros(1,nTimeSteps); % Density of integrin type 2 as a function of time
FcAll = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
xcAll = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
xcSumAll = zeros(1,nTimeSteps);
Nnew_curAll = zeros(1,nTimeSteps);
NnewAll = zeros(1,nTimeSteps);
NallAll = zeros(1,nTimeSteps);
k_actinAll = zeros(1,nTimeSteps);
%% Simulation through time
p = 0;
if verbose
    f100=figure(100); f100.Position(3:4)=[900 600];
end

for t=timeStepAll
    p = p + 1;
    koff1 = kof1*koffcb(Fc,ion); % koff 1 in each clutch
    koff2 = kof2*koffcb(Fc,ion); %koff 2 in each clutch
    kuf = 1.*exp(-7.573).*exp(1.786e12.*abs(Fc).*pt); % k unfolding in each clutch
    kf = 1.*exp(13.07).*exp(-2.288e12.*abs(Fc).*pt); % k refolding in each clutch

    % velocity is determined by the force (inversely with the force by clutch = traction)
    % This is something that's needed to be updated as the actin retrograde
    % flow is not only due to myosin. For myosin-free simulation, vu, the
    % unloaded myosin motor velocity, should be zero. 
%     vf = vu.*(1 - ksub.*xsub./Fs) +  v_actin*(1-ksub.*xsub./Fs_actin); %C_actin/(-4*ksub.*xsub*R+C_actin)*v_actin; % - 0.2*v_actin; 

    % For bound clutches, we create vector k (koff) and vectors kvuf
    % (unfolding) and kvf (refolding)
    % for unbound clutches, we create two vectors k1 and k2 with kon

    k = zeros(nc,1);
    kvuf = zeros(nc,1);
    kvf = zeros(nc,1);
    k1 = zeros(nc,1);
    k2 = zeros(nc,1);
    indbound1 = find(bound == 1);
    indbound2 = find(bound == 2);
    indunbound = find(bound == 0);
    k(indbound1) = koff1(indbound1);
    k(indbound2) = koff2(indbound2);
    kvuf(indbound1) = kuf(indbound1);
    kvuf(indbound2) = kuf(indbound2);
    kvf(indbound1) = kf(indbound1);
    kvf(indbound2) = kf(indbound2);
    k1(indunbound) = kont1*dint1;
    k2(indunbound) = kont2*dint2;

    if verboseEach 
        if p==1 
            ax1 = subplot(6,2,1); plot(t,sum(k),'.-'); hold on; title('k, unbinding'); 
            ax2 = subplot(6,2,3); plot(t,sum(k1),'.-'); hold on; title('k1, binding');
            ax3 = subplot(6,2,5); plot(t,sum(kvuf),'.-'); hold on; title('kvuf, unfolding');
            ax4 = subplot(6,2,7); plot(t,sum(kvf),'.-'); hold on; title('konv, refolding'); 
            ax5 = subplot(6,2,9); plot(t,sum(konv),'.-'); hold on; title('konv, vinculin binding'); 
        else
            plot(ax1, t,sum(k),'.-');
            plot(ax2, t,sum(k1),'.-');
            plot(ax3, t,sum(kvuf),'.-');
            plot(ax4, t,sum(kvf),'.-');
            plot(ax5, t,sum(konv),'.-');
        end
    end
    
    %We calculate the times for all events:
    teventub = -log(rand(nc,1))./k;  %Times for unbinding events
    teventb1 = -log(rand(nc,1))./(k1); %Times for binding events, int. 1
    teventb2 = -log(rand(nc,1))./(k2); %Times for binding events, int. 2
    teventuf = -log(rand(nc,1))./kvuf; % Times for unfolding events
    teventuf(folding == 1) = 0; % If molecule is already unfolded we set unfolding time to 0
    teventf = -log(rand(nc,1))./kvf; % Times for refolding events
    teventvinc = -log(rand(nc,1))./(konv); % Time for vinculin binding

    % If binding of int2 happens after binding of int1 we don't execute it.
    teventb2(teventb2 - teventb1 > 0) = ts +1; 
    % If refolding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventf > 0) = ts +1; 
    % If unbinding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventub > 0) = ts +1; 

    % We find which events happen before ts and execute them:
    indub = (teventub < ts);
    indb1 = (teventb1 < ts);
    indb2 = (teventb2 < ts);
    induf = (teventuf < ts);
    indvinculin = (teventuf + teventvinc < ts);

    boundbefore = bound;
    bound(indub) = 0;
    bound(indb1) = 1;
    bound(indb2) = 2;

    folding(induf) = 1;
    folding(indvinculin) = 2;

    % For the bonds that unbind, we add integrins if vinculin is bound, and
    % remove them if it is unbound.

    dint1 = dint1 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 12));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 11));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 10));

    if dint1 < dint1i
        dint1 = dint1i;
    elseif dint1 > mr
        dint1 = mr;
    end

    dint2 = dint2 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 22));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 21));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 20));

    if dint2 < dint2i
        dint2 = dint2i;
    elseif dint2 > mr
        dint2 = mr;
    end
    indub = (teventub < ts);
    indb1 = (teventb1 < ts);
    indb2 = (teventb2 < ts);
    induf = (teventuf < ts);
    indvinculin = (teventuf + teventvinc < ts);

    if verboseEach 
        if p==1 
            ax1_2 = subplot(6,2,2); plot(t,sum(indub),'.-'); hold on; title('total indub'); 
            ax2_2 = subplot(6,2,4); plot(t,sum(indb1),'.-'); hold on; title('total, indb1');
            ax3_2 = subplot(6,2,6); plot(t,sum(indb2),'.-'); hold on; title('total indb2');
            ax4_2 = subplot(6,2,8); plot(t,sum(induf),'.-'); hold on; title('total induf'); 
            ax5_2 = subplot(6,2,10); plot(t,sum(indvinculin),'.-'); hold on; title('total indvinculin'); 
        else
            plot(ax1_2, t,sum(indub),'.-');
            plot(ax2_2, t,sum(indb1),'.-');
            plot(ax3_2, t,sum(indb2),'.-');
            plot(ax4_2, t,sum(induf),'.-');
            plot(ax5_2, t,sum(indvinculin),'.-');
        end
    end
    
    %We now reset the folding vector for the unbound clutches:
    folding(indub) = 0;

    % We recalculate all elements:
    boundbin = logical(bound); % when there is no bound clutch at all, force will be zero

%     xc = xc + vf.*ts.*boundbin; %Position of each clutch
    % Determining xc based on force balance. 
    % Space-based Nnew_cur addition (instead force-based, which didn't produce
    % stiffness-dependence)
    
    FcMax = max(abs(Fc)); % Total tension within F_actin (same as force in adhesion)
%     if FcMax >= abs(Fs_actin) %this case, actin monomer can be added
%         Nnew_cur=0;
%     elseif FcMax >= 4/5*abs(Fs_actin)
%         Nnew_cur=0.1;
%     elseif FcMax >= 3/5*abs(Fs_actin)
%         Nnew_cur=0.2;
%     elseif FcMax >= 2/5*abs(Fs_actin)
%         Nnew_cur=0.3;
%     elseif FcMax >= 1/5*abs(Fs_actin)
%         Nnew_cur=0.4;
%     else
%         Nnew_cur=0.5;
%     end

    Nnew_cur = NnMax - NnMax/Fs_actin*FcMax;
%     Nnew_cur = ((prevXcMax+d-q*L*Nall)*pNnew/(q*L*Nall));
      if Nnew_cur<0;Nnew_cur=0;end
%     while Nnew_cur<0
%         Nnew_cur = Nnew_cur+0.1;
%     end
%     Nnew_cur=0;
%     maxActin_0=(10*ts)/(5e-3);
%     maxActin=maxActin_0;
%     %Nnew_cur=(FcNext/(L*k_actin))*(Nall-1);
%     while (Nnew_cur<maxActin) %actin addition
%         %FcNext=max(abs(Fc))+Nnew_cur/(Nall+Nnew_cur)*L*k_actin;
%         Fa0_l=(Nnew+Nnew_cur)*L*k_actin/(Nall+Nnew_cur);
%         Fa_l=Fa0_l*(1-exp(-k0*(boundTime+ts)/pot));
%         maxActin=maxActin_0*(1-Fa_l/Fs_actin)^0.5;
%         Nnew_cur=Nnew_cur+1;
%     end
%     
%     if Nnew_cur>=1;Nnew_cur=Nnew_cur-1;end

    Nnew = Nnew + Nnew_cur;
    Nall = Norg + Nnew;
    Nc = sum(boundbin);
    if Nc>0
        % elasticity-only considered
%         xc(boundbin) = k_actin*Nnew*(ksub+kc*Nc)*L/(ksub*kc*Nall*Nc + k_actin*(ksub+Nc*kc)); % clutch position
        % viscoelasticity-considered
        % Now we have to count unbound clutches that are undergoing
        % relaxation
        
        xc_dot = 1/eta*(k_actin/Nall*(Nnew*L-xc(boundbin)) - ...
            Nc*kc*ksub*xc(boundbin)/(Nc*kc+ksub));
        xc(boundbin) = xc(boundbin) + xc_dot*ts;
        vf = (max(xc) - max(xc_prev))/ts;
        % k_actin update is needed for next round
%         k_actin = k_actin + (pK*Nnew*L-max(xc))*a*k_actin/(pK*Nnew*L); 
    else %Nc==0, then it slips, and by added actin springs (i.e., Nnew), the edge advances
%         xc = zeros(nc,1);
%         vf = Nnew*L/ts;
%         k_actin = dActin * k_basicActin; % actin polymer elasticity
        Nnew = 0;
        Nall = Norg + Nnew;
        % For any previous bound clutches
        prev_bound = xc>0;
        % viscoelasticity-considered
        xc_dot = 1/eta*(k_actin/Nall*(Nnew*L-xc(prev_bound)) - ...
            Nc*kc*ksub*xc(prev_bound)/(Nc*kc+ksub));
        xc(prev_bound) = xc(prev_bound) + xc_dot*ts;
        vf = (max(xc) - max(xc_prev))/ts;        
    end
%     xsub = k_actin*kc*Nnew*L*Nc/(ksub*kc*Nall*Nc+k_actin*(ksub+kc*Nc)); %Substrate position
    xc(~boundbin) = 0;
    xsub = sum(kc*xc)/(ksub+Nc*kc); %Substrate position
    if verboseEach 
        if p==1 
            ax3_1 = subplot(6,2,11); plot(t,xc,'k.'); hold on; title('x_c'); 
            ax3_2 = subplot(6,2,12); plot(t,xsub,'b.'); hold on; title('x_{sub}');
        else
            plot(ax3_1, t,xc,'k.');
            plot(ax3_2, t,xsub,'b.');
        end
    end
    %xsub = kc.*sum(xc.*boundbin)./(ksub+sum(boundbin).*kc); %Substrate
    %position need to be compared with the expression result above
    
    xc(bound == 0) = xsub;
    f(p) = xsub*ksub;  % Force on substrate
    v(p) = vf;          % Actin rearward speed
    nb1(p) = sum(bound == 1); % Number of bound clutches (integrin 1)
    nb2(p) = sum(bound == 2); % Number of bound clutches (integrin 2)

    if t == 0
        dint1t(1) = dint1i;
        dint2t(1) = dint2i;
    else
        dint1t(p) = dint1;
        dint2t(p) = dint2;
    end
    Fc = kc.*(xc - xsub); % Force in each clutch
    FcAll(p) = max(abs(Fc)); % Force at clutch
    prevXcMax = max(xc);
    xcAll(p) = max(xc); % xc at clutch
    xcSumAll(p) = sum(xc); % xc at clutch
    Nnew_curAll(p) = Nnew_cur;
    NnewAll(p) = Nnew;
    NallAll(p) = Nall;
    xc_prev = xc;
    k_actinAll(p) = k_actin;
end
% if(Nnew_cur>=maxActin)
%     disp(['Maximum Actin Reached']);
% else
%     disp(['Stall Force Reached'])
%end
q=1000;
a =1700e-9; % Radius of adhesion (m) 1500e-9

lf=length(1e9*abs(v));
ff=fft(1e9*(abs(v)-mean(abs(v))));
pf=abs(ff).^2;
p1=pf(1:floor((lf+1)/2));
%p1(1)=0;
fff=1/(lf*ts)*(0:floor((lf-1)/2));
sfft={fff,p1};
saveFreq=0;



if verbose 
    subplot(3,4,1); plot(timeStepAll,abs(f)/(pi*a^2),'.-'); title('Traction'); xlabel('Time (sec)'); ylabel('Traction (Pa)')
    subplot(3,4,2); plot(timeStepAll,1e9*abs(v));  title('Flow velocity'); xlabel('Time (sec)'); ylabel('Velocity (nm/s)')
    subplot(3,4,3); plot(timeStepAll,nb1);  title('Bound integrin'); xlabel('Time (sec)'); ylabel('Number (1)')
    subplot(3,4,4); plot(timeStepAll,abs(FcAll));  title('FcAll'); xlabel('Time (sec)'); ylabel('FcAll')
    subplot(3,4,5); plot(timeStepAll,xcAll);  title('xcAll'); xlabel('Time (sec)'); ylabel('xcAll')
    subplot(3,4,6); plot(timeStepAll,xcSumAll);  title('xcSumAll'); xlabel('Time (sec)'); ylabel('xcSumAll')
    subplot(3,4,7); plot(timeStepAll,Nnew_curAll);  title('Nnew_{cur}'); xlabel('Time (sec)'); ylabel('N')
    subplot(3,4,8); plot(timeStepAll,NnewAll);  title('Nnew'); xlabel('Time (sec)'); ylabel('N')
    subplot(3,4,9); plot(timeStepAll,NallAll);  title('Nall'); xlabel('Time (sec)'); ylabel('N')
    subplot(3,4,10); plot(timeStepAll,k_actinAll);  title('k_{actin}'); xlabel('Time (sec)'); ylabel('k actin (N/m)')

    subplot(3,4,11); plot(fff,p1);  title('Velocity FFT'); xlabel('Frequency (Hz)'); ylabel('Power')
    drawnow
    if saveFreq
        eImg={dir('*.tif').name};
        eImg=cellfun(@(f) str2double(f(1:end-4)),eImg,'UniformOutput',false);
        if (isempty(eImg))
            nameImg=0;
        else
            nameImg=max([eImg{:}])+1;
        end
        saveas(f100,[num2str(nameImg) '.tif'])
    end
end
if showSpeeds
    a =1700e-9; % Radius of adhesion (m) 1500e-9
    E = 9*ksub./(4*pi*a);
    figure()
    plot(timeStepAll,abs(v)*1e6*60);  title('Flow velocity'); xlabel('Time (sec)'); ylabel('Velocity (\mum/min)')
    title(num2str(E*10^-3))
end
mf = mean(f); %Mean force on substrate

%v(1)=0;

mv = mean(v); %Mean rearward speed
mnb1 = mean(nb1); % Mean number of bound clutches
mnb2 = mean(nb2); % Mean number of bound clutches
mdint1 = mean(dint1t); % Mean density, integrin 1
mdint2 = mean(dint2t); % Mean density, integrin 2
mfc=mean(FcAll);
return
