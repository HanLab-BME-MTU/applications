function [mf,mv,mnb1,mnb2,mdint1,mdint2,mfc] = ...
    clutchModelActinElasticityMichels(nm,fm1,vu,nc,dint1,dint2,kont1,...
                            kont2,kof1,kof2,kc,ksub,konv,pt,mr,intadd,ion,...
                            v_actin, dActin, tTotal,d,verbose,actinRate,pot)
% function [mf,mv,mnb1,mnb2,mdint1,mdint2] =
% clutchModelActinElasticity(nm,fm1,vu,nc,dint1,dint2,kont1,kont2,kof1,kof2,
%                            kc,ksub,konv,pt,mr,intadd,ion) 
% calculates the mean force on the substrate generated by a rearward
% flowing csk according to the model of Chan and Odde (Science, 2008). 
% In addition, this function considers 2 integrin populations with
% different kon and koff (Elosegui-Artola 2016). Furthermore, the actin
% flow in the model is now elasticity driven, and the kinematic interaction
% between actin and the clutch is no longer hard-wired from the velocity,
% but based on force equilibrium affected by elasticity of components
% including that of actin. - Sangyoon Han
% 
% Input Parameters of the model (default values from chan and odde listed):
%       nm      Number of myosin motors (= 75)
%       fm1     Stall force of 1 motor (N) (= -2e-12) 
%       vu      Unloaded myosin motor velocity (m/s) (= -120e-9)
%       nc      Number of molecular clutches (fibronectin molecules) (= 75)
%       dint1:  Density of integrin molecules, type 1 (integrins/um2).
%       dint2:  Density of integrin molecules, type 2 (integrins/um2).
%       kont1   True on-rate (um2/s), 1st integrin type (= 1) 
%       kont2   Same for 2nd integrin type
%       kof1    Koff for 1st integrin type (scaling factor with respect to data
%               from Kong et al JCB paper).
%       kof2    Same for 2nd integrin type.
%       kc      Clutch spring constant (we assume the same for both
%               integrins) (N/m) (= 5e-3)
%       ksub    Substrate spring constant (N/m) (= 0.1e-3; or
%               10.^([-2:0.1:2]).*1e-3)
%       konv    Binding rate between vinculin and unfolded talin
%       pt      Fraction of clutch force experienced by talin
%       rf      Threshold force that leads to reinforcement (addition of another
%               integrin)
%       mr      Maximum integrin density for each integrin
%       intadd  Number of integrins added per sq. micron every time reinforcement happens.
%       ion     mn or mg, to take corresponding koff data from kong et al JCB paper
%       v_actin Unloaded actin-polymerization-driven actin flow speed
%       dActin  Density of F-actin molecules (which can be low for
%               Arp2/3-inhibited actin and intermediate for
%               Formin-inhibited actin). (Need a reference, 300 for now for
%               control). This will also determine the elasticity of actin
%               by k_actin = dActin * k_basicActin where k_basicActin is
%               calibrated by a published article (?)
%       tTotal  Total time of simulation (default: 100 s)
%       d       Distance of the adhesion from cell membrane. This will determine how many
%               monomers are in-between. (m). Default: 2 um = 2e-6 m.
% 
% Output parameters
%       mf              Mean force on substrate (N)
%       mv              Mean rearward speed (m/s)
%       mnb1, mnb2:     Mean number of bound clutches for both integrins
%       mdint1, mdint2: Mean densities of both integrin types
% 
% Adapted from Roca-cusachs,
% Sangyoon Han, May 2022

%% Initialize variables:
if nargin<20
    tTotal = 100; % total time period
    d = 2e-6; % distance from edge to adhesion
elseif nargin<21
    d = 2e-6; % distance from edge to adhesion in m
end
% verbose = false; %1; 
verboseEach = false; %true; %false;
Fs = nm.*fm1; %Stall force of the system 
kB = 1.38064852e-23; %m2 kg s-2 K-1
T = 278; %K
% deltaActin = 2.7e-9; % m
c = 0.8; %c is a coefficient that accounts for geometrical effects: 0.13 is for sphere, maybe 1 for a flat edge. 
C_actin = kB*T*c*dActin; %constant for force-velocity relationship in actin: This is assumption for now 
R = 1e-6; % m, the radius of curvature of edge. Given normal cell, it can be ~ 10-30 um
Fs_actin = C_actin/(4*R); %-C_actin/(4*R); % stall force for actin addition
L = 2e-9; % m, the length of each actin monomer spring segment. 
Norg = d/L; % The number of actin springs in-between the membrane and adhesion
Nnew = 0; % Newly-added actin springs at the membrane in front of the adhesion
Nall = Norg + Nnew; % all new actin

k_basicActin = 1e-6; % basic actin elasiticity: currently totally ambiguous.
k_actin = dActin * k_basicActin; % actin polymer elasticity
a = 0.0001; %Adaptation factor for k_actin
pK = 0.6; %Max contraction limit: There should be an ultimate strain per spring.
pNnew = 2; %proportion of distance difference for space for new actin addition.
q = 0.1; % Max conpression limit of the spring


ts = 5e-3; % Time step used for calculation
xsub = 0; %Substrate displacement
prevXcMax = 0; %  clutch displacement in the previous step
bound = zeros(nc,1); % Binding status of each clutch (0 unbound, 1 1st integrin, 2 2nd integrin)
boundTime=0;
unboundTime=0;
Fa_last=0;
folding = zeros(nc,1); % Folding status of each clutch (0 folded, 1 unfolded, 2 vinculin-bound)
xc = zeros(nc,1); %displacement of each clutch
xc_prev = zeros(nc,1); %displacement of each clutch in previous time step
Fc = zeros(nc,1); % Force in each clutch
dint1i = dint1; %Density of integrin type 1 before reinforcement
dint2i = dint2; %Density of integrin type 2 before reinforcement

%aElon=1.72; %um/s rate of elongation
%maxActin=actinRate*(aElon*ts*10e-6)/L; % (rate of elongation * interval * um to m)/Length of individual actin molecule
%timeAct
% in=(aElon*10e-6)^-1*L;
%ts=timeActin;
%pot=0.01e-4;
%k0=k_actin;
vf_last=1e-5;

timeStepAll = 0:ts:tTotal;
nTimeSteps = numel(timeStepAll);
f = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
v = zeros(1,nTimeSteps);  %Rearward speed as a function of time
nb1 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 1
nb2 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 2
dint1t = zeros(1,nTimeSteps); % Density of integrin type 1 as a function of time
dint2t = zeros(1,nTimeSteps); % Density of integrin type 2 as a function of time
FcAll = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
xcAll = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
xcSumAll = zeros(1,nTimeSteps);
Nnew_curAll = zeros(1,nTimeSteps);
NnewAll = zeros(1,nTimeSteps);
NallAll = zeros(1,nTimeSteps);
k_actinAll = zeros(1,nTimeSteps);
%% Simulation through time
p = 0;




if verbose
    f100=figure('Name',num2str(ksub)); f100.Position=[500,0,2000 1000];
end

for t=timeStepAll
    p = p + 1;
    koff1 = kof1*koffcb(Fc,ion); % koff 1 in each clutch
    koff2 = kof2*koffcb(Fc,ion); %koff 2 in each clutch
    kuf = 1.*exp(-7.573).*exp(1.786e12.*abs(Fc).*pt); % k unfolding in each clutch
    kf = 1.*exp(13.07).*exp(-2.288e12.*abs(Fc).*pt); % k refolding in each clutch

    % velocity is determined by the force (inversely with the force by clutch = traction)
    % This is something that's needed to be updated as the actin retrograde
    % flow is not only due to myosin. For myosin-free simulation, vu, the
    % unloaded myosin motor velocity, should be zero. 
%     vf = vu.*(1 - ksub.*xsub./Fs) +  v_actin*(1-ksub.*xsub./Fs_actin); %C_actin/(-4*ksub.*xsub*R+C_actin)*v_actin; % - 0.2*v_actin; 

    % For bound clutches, we create vector k (koff) and vectors kvuf
    % (unfolding) and kvf (refolding)
    % for unbound clutches, we create two vectors k1 and k2 with kon

    k = zeros(nc,1);
    kvuf = zeros(nc,1);
    kvf = zeros(nc,1);
    k1 = zeros(nc,1);
    k2 = zeros(nc,1);
    indbound1 = find(bound == 1);
    indbound2 = find(bound == 2);
    indunbound = find(bound == 0);
    k(indbound1) = koff1(indbound1);
    k(indbound2) = koff2(indbound2);
    kvuf(indbound1) = kuf(indbound1);
    kvuf(indbound2) = kuf(indbound2);
    kvf(indbound1) = kf(indbound1);
    kvf(indbound2) = kf(indbound2);
    k1(indunbound) = kont1*dint1;
    k2(indunbound) = kont2*dint2;

    if verboseEach 
        if p==1 
            ax1 = subplot(6,2,1); plot(t,sum(k),'.-'); hold on; title('k, unbinding'); 
            ax2 = subplot(6,2,3); plot(t,sum(k1),'.-'); hold on; title('k1, binding');
            ax3 = subplot(6,2,5); plot(t,sum(kvuf),'.-'); hold on; title('kvuf, unfolding');
            ax4 = subplot(6,2,7); plot(t,sum(kvf),'.-'); hold on; title('konv, refolding'); 
            ax5 = subplot(6,2,9); plot(t,sum(konv),'.-'); hold on; title('konv, vinculin binding'); 
        else
            plot(ax1, t,sum(k),'.-');
            plot(ax2, t,sum(k1),'.-');
            plot(ax3, t,sum(kvuf),'.-');
            plot(ax4, t,sum(kvf),'.-');
            plot(ax5, t,sum(konv),'.-');
        end
    end
    
    %We calculate the times for all events:
    teventub = -log(rand(nc,1))./k;  %Times for unbinding events
    teventb1 = -log(rand(nc,1))./(k1); %Times for binding events, int. 1
    teventb2 = -log(rand(nc,1))./(k2); %Times for binding events, int. 2
    teventuf = -log(rand(nc,1))./kvuf; % Times for unfolding events
    teventuf(folding == 1) = 0; % If molecule is already unfolded we set unfolding time to 0
    teventf = -log(rand(nc,1))./kvf; % Times for refolding events
    teventvinc = -log(rand(nc,1))./(konv); % Time for vinculin binding

    % If binding of int2 happens after binding of int1 we don't execute it.
    teventb2(teventb2 - teventb1 > 0) = ts +1; 
    % If refolding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventf > 0) = ts +1; 
    % If unbinding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventub > 0) = ts +1; 

    % We find which events happen before ts and execute them:
    indub = (teventub < ts);
    indb1 = (teventb1 < ts);
    indb2 = (teventb2 < ts);
    induf = (teventuf < ts);
    indvinculin = (teventuf + teventvinc < ts);

    boundbefore = bound;
    bound(indub) = 0;
    bound(indb1) = 1;
    bound(indb2) = 2;

    folding(induf) = 1;
    folding(indvinculin) = 2;

    % For the bonds that unbind, we add integrins if vinculin is bound, and
    % remove them if it is unbound.

    dint1 = dint1 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 12));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 11));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 10));

    if dint1 < dint1i
        dint1 = dint1i;
    elseif dint1 > mr
        dint1 = mr;
    end

    dint2 = dint2 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 22));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 21));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 20));

    if dint2 < dint2i
        dint2 = dint2i;
    elseif dint2 > mr
        dint2 = mr;
    end
    indub = (teventub < ts);
    indb1 = (teventb1 < ts);
    indb2 = (teventb2 < ts);
    induf = (teventuf < ts);
    indvinculin = (teventuf + teventvinc < ts);

    if verboseEach 
        if p==1 
            ax1_2 = subplot(6,2,2); plot(t,sum(indub),'.-'); hold on; title('total indub'); 
            ax2_2 = subplot(6,2,4); plot(t,sum(indb1),'.-'); hold on; title('total, indb1');
            ax3_2 = subplot(6,2,6); plot(t,sum(indb2),'.-'); hold on; title('total indb2');
            ax4_2 = subplot(6,2,8); plot(t,sum(induf),'.-'); hold on; title('total induf'); 
            ax5_2 = subplot(6,2,10); plot(t,sum(indvinculin),'.-'); hold on; title('total indvinculin'); 
        else
            plot(ax1_2, t,sum(indub),'.-');
            plot(ax2_2, t,sum(indb1),'.-');
            plot(ax3_2, t,sum(indb2),'.-');
            plot(ax4_2, t,sum(induf),'.-');
            plot(ax5_2, t,sum(indvinculin),'.-');
        end
    end
    
    %We now reset the folding vector for the unbound clutches:
    folding(indub) = 0;

    % We recalculate all elements:
    boundbin = logical(bound); % when there is no bound clutch at all, force will be zero

%     xc = xc + vf.*ts.*boundbin; %Position of each clutch
    % Determining xc based on force balance. 
%     FcMax = max(abs(Fc)); % Total tension within F_actin (same as force in adhesion)
%     if FcMax >= abs(Fs_actin) %this case, actin monomer can be added
%         Nnew_cur=0;
%     elseif FcMax >= 4/5*abs(Fs_actin)
%         Nnew_cur=1;
%     elseif FcMax >= 3/5*abs(Fs_actin)
%         Nnew_cur=2;
%     elseif FcMax >= 2/5*abs(Fs_actin)
%         Nnew_cur=3;
%     elseif FcMax >= 1/5*abs(Fs_actin)
%         Nnew_cur=4;
%     else
%         Nnew_cur=5;
%     end
    % Space-based Nnew_cur addition (instead force-based, which didn't produce
    % stiffness-dependence)


%%start of model
    Nnew_cur=0;
    maxActin_0=actinRate*(10*ts)/(5e-3);
    maxActin=maxActin_0;
    %Nnew_cur=(FcNext/(L*k_actin))*(Nall-1);

    while (Nnew_cur<maxActin) %actin addition
        %FcNext=max(abs(Fc))+Nnew_cur/(Nall+Nnew_cur)*L*k_actin;
        k0=k_actin/(Nall+Nnew_cur);
        Fa0_l=(Nnew+Nnew_cur)*L*k_actin/(Nall+Nnew_cur);
        Fa_l=Fa0_l*(1-exp(-k0*(boundTime+ts)/pot));
        maxActin=maxActin_0*(1-Fa_l/Fs_actin);
        %maxActin=maxActin_0*(coth(1-Fa_l/Fs_actin)-1);
        Nnew_cur=Nnew_cur+1;

    end
    
    if Nnew_cur>=1;Nnew_cur=Nnew_cur-1;end
    
            %Nnew_cur = round((prevXcMax+d-q*L*Nall)*pNnew/(q*L*Nall));
    
        Nnew = Nnew + Nnew_cur;
        Nall = Norg + Nnew;
        Nc = sum(boundbin);
        k0=k_actin/Nall;
    %     if (Nc==0)
    %         boundbin(1)=1;
    %         Nc=1;
    %     end 
    
    
        xc(~boundbin) = 0;
        if Nc>0 %if no slip
        
            unboundTime=0;
            Fa0=Nnew*L*k_actin/(Nall);
            Fa=Fa0*(1-exp(-k0*boundTime/pot));
            xc(boundbin)=Fa*(kc*Nc+ksub)/(kc*ksub);
            boundTime=boundTime+ts;
            Fa_last=Fa;
            maxBound=boundTime;
            %xc(boundbin) = k_actin*Nnew*(ksub+kc*Nc)*L/(ksub*kc*Nall*Nc + k_actin*(ksub+Nc*kc)); % clutch position
            vf = (max(xc) - max(xc_prev))/ts;
            vf_last=vf;
            % k_actin update is needed for next round
    %         k_actin = k_actin + (pK*Nnew*L-max(xc))*a*k_actin/(pK*Nnew*L); 
        else %Nc==0, then it slips, and by added actin springs (i.e., Nnew), the edge advances
            boundTime=0;
            %xc(boundbin)=Fa/(kc*Nc-(kc*Nc)^2/(kc*Nc+ksub));
            unboundTime=unboundTime+ts;
            %vf=ts*Fa/(mActin*Nall);
            %vf_last=vf;
            xc = zeros(nc,1);%+1e-12;
            vf = Nnew_cur*L/ts;
            %vf=vf_last;
    
            %vf = (max(xc) - max(xc_prev))/ts;
    %         k_actin = dActin * k_basicActin; % actin polymer elasticity
            Nnew = 0;
            %Nall=Norg;
            %Nall=Nnew+Nnew_cur;
        end
    %     xsub = k_actin*kc*Nnew*L*Nc/(ksub*kc*Nall*Nc+k_actin*(ksub+kc*Nc)); %Substrate position
        
        xsub = sum(kc*xc*Nc)/(ksub+Nc*kc); %Substrate position
        if verboseEach 
            if p==1 
                ax3_1 = subplot(6,2,11); plot(t,xc,'k.'); hold on; title('x_c'); 
                ax3_2 = subplot(6,2,12); plot(t,xsub,'b.'); hold on; title('x_{sub}');
            else
                plot(ax3_1, t,xc,'k.');
                plot(ax3_2, t,xsub,'b.');
            end
        end
        %xsub = kc.*sum(xc.*boundbin)./(ksub+sum(boundbin).*kc); %Substrate
        %position need to be compared with the expression result above
        
    %     xc(bound == 0) = xsub;
        f(p) = xsub*ksub;  % Force on substrate
        v(p) = vf;          % Actin rearward speed
        Fc = kc.*(xc - xsub); % Force in each clutch


        
        nb1(p) = sum(bound == 1); % Number of bound clutches (integrin 1)
        nb2(p) = sum(bound == 2); % Number of bound clutches (integrin 2)
    
        if t == 0
            dint1t(1) = dint1i;
            dint2t(1) = dint2i;
        else
            dint1t(p) = dint1;
            dint2t(p) = dint2;
        end
        
        FcAll(p) = max(Fc); % Force at clutch
        prevXcMax = max(xc);
        xcAll(p) = max(xc); % xc at clutch
        xcSumAll(p) = sum(xc); % xc at clutch
        Nnew_curAll(p) = Nnew_cur;
        NnewAll(p) = Nnew;
        NallAll(p) = Nall;
        xc_prev = xc;
        k_actinAll(p) = k_actin;
end
% if(Nnew_cur>=maxActin)
%     disp(['Maximum Actin Reached']);
% else
%     disp(['Stall Force Reached'])
%end
q=1000;
a =1700e-9; % Radius of adhesion (m) 1500e-9
if verbose 
    subplot(3,4,1); plot(timeStepAll,abs(f)/(pi*a^2),'.-'); title('Traction'); xlabel('Time (ms)'); ylabel('Traction (Pa)')
    subplot(3,4,2); plot(timeStepAll,1e9*abs(v));  title('Flow velocity'); xlabel('Time (ms)'); ylabel('Velocity (nm/s)')
    subplot(3,4,3); plot(timeStepAll,nb1);  title('Bound integrin'); xlabel('Time (ms)'); ylabel('Number (1)')
    subplot(3,4,4); plot(timeStepAll,abs(FcAll));  title('FcAll'); xlabel('Time (ms)'); ylabel('FcAll')
    subplot(3,4,5); plot(timeStepAll,xcAll);  title('xcAll'); xlabel('Time (ms)'); ylabel('xcAll')
    subplot(3,4,6); plot(timeStepAll,xcSumAll);  title('xcSumAll'); xlabel('Time (ms)'); ylabel('xcSumAll')
    subplot(3,4,7); plot(timeStepAll,Nnew_curAll);  title('Nnew_{cur}'); xlabel('Time (ms)'); ylabel('N')
    subplot(3,4,8); plot(timeStepAll,NnewAll);  title('Nnew'); xlabel('Time (ms)'); ylabel('N')
    subplot(3,4,9); plot(timeStepAll,NallAll);  title('Nall'); xlabel('Time (ms)'); ylabel('N')
    subplot(3,4,10); plot(timeStepAll,k_actinAll);  title('k_{actin}'); xlabel('Time (ms)'); ylabel('k actin (N/m)')
    drawnow
end
% figure; plot(timeStepAll,abs(FcAll));  title(['Fc | Ksub : ' num2str(ksub)]); xlabel('Time (ms)'); ylabel('FcAll')
mf = mean(f); %Mean force on substrate

%v(1)=0;

mv = mean(v); %Mean rearward speed
mnb1 = mean(nb1); % Mean number of bound clutches
mnb2 = mean(nb2); % Mean number of bound clutches
mdint1 = mean(dint1t); % Mean density, integrin 1
mdint2 = mean(dint2t); % Mean density, integrin 2
mfc=mean(FcAll);
return

nm = 800; %Number of myosin motors, optimal fit 800
fm1 = -2e-12; % Stall force of 1 motor (N)
vu = -110e-9; % Unloaded myosin motor velocity (m/s)
kc = 1; % Clutch spring constant (N/m)
pt = 0.073; % fraction of force experienced by talin 0.073
konv = 1e8; % on-rate of vinculin to unfolded talin
mr = 300*50;  % Maximum integrin density for each integrin
% intadd = 2.4; % Number of integrins added per sq. micron every time reinforcement happens.
a =1700e-9; % Radius of adhesion (m) 1500e-9
ksub = 10.^(-0.1:0.1:2).*1e-3; %Range of substrate stiffness
kont1 = 2.11e-4; %3.33e-4; % True on-rate (um2/s), 1st integrin type
kont2 = 0; % True on-rate (um2/s), 2nd integrin type
kof2 = 1.5;
E = 9*ksub./(4*pi*a);
intaddctrl = 24; % At 1000 s: 4 at 100 s: 24
nc10 = 1200; %Number of molecular clutches for 10 ug/ml fn 1200
nc1 = 750; %Number of molecular clutches for 1 ug/ml fn 800
nc100 = 1650; %Number of molecular clutches for 100 ug/ml fn
vu = 0; % zero myosin contraction produces zero shortening velocity
v_actin = -12e-9; %-2.6um/min e-6/60 = -4.5e-8 m/s vu = -110e-9; % Unloaded myosin motor velocity (m/s)
intadd = 0; % Number of integrins added per sq. micron every time reinforcement happens.
dActin = 1e6; % density of actin at the leading edge #/um
kont1 = 2.11e-3; %increased from 2.11e-4 True on-rate (um2/s), 1st integrin type
kont2 = 2.11e-3; % True on-rate (um2/s), 2nd integrin type
kof1 = 9; % from 90 previously (5/26/2022)
kof2 = 9; % from 90 previously (5/26/2022)
dint1 = 200; %Density of integrin molecules, type 1 (integrins/um2).
dint2 = 200;   %Density of integrin molecules, type 2 (integrins/um2).
ion = 'mg'; %'mg'; %'mg'; % 'cm' doesn't makes sense. Why koff goes up with less force?
nc = nc10;

[mfi,mvi,mnb1i,mnb2i,mdint1i,mdint2i] = ...
clutchModelActinElasticity(nm,fm1,vu,nc,dint1,dint2,kont1,...
kont2,kof1,kof2,kc,ksub(end),konv,pt,mr,intadd,ion,v_actin,dActin,10,2e-6);