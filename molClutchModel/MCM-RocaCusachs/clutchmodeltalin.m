
function [mf,mv,mnb1,mnb2,mdint1,mdint2] = clutchmodeltalin(nm,fm1,vu,nc,dint1,dint2,kont1,kont2,kof1,kof2,kc,ksub,konv,pt,mr,intadd,ion)
                                          
% This function calculates the mean force on the substrate generated by a
% rearward flowing csk according to the model of Chan and Odde (Science,
% 2008). In addition, it considers 2 integrin populations with different
% kon and koff.

% Input Parameters of the model (default values from chan and odde listed):

% nm = 75; %Number of myosin motors
% fm1 = -2e-12; % Stall force of 1 motor (N)
% vu = -120e-9; % Unloaded myosin motor velocity (m/s)
% nc = 75; %Number of molecular clutches (fibronectin molecules)
% dint1: Density of integrin molecules, type 1 (integrins/um2).
% dint2: Density of integrin molecules, type 2 (integrins/um2).
% kont1 = 1; % True on-rate (um2/s), 1st integrin type
% kont2:  Same for 2nd integrin type
% kof1: Koff for 1st integrin type (scaling factor with respect to data
%       from Kong et al JCB paper).
% kof2: Same for 2nd integrin type.
% kc = 5e-3; % Clutch spring constant (we assume the same for both integrins) (N/m)
% ksub = 0.1e-3; % 10.^([-2:0.1:2]).*1e-3; % Substrate spring constant (N/m)
% konv: binding rate between vinculin and unfolded talin
% pt: Fraction of clutch force experienced by talin
% rf: Threshold force that leads to reinforcement (addition of another
%     integrin)
% mr: Maximum integrin density for each integrin
% intadd: Number of integrins added per sq. micron every time reinforcement happens.
% ion: mn or mg, to take corresponding koff data from kong et al JCB paper

% Output parameters;

% mf: Mean force on substrate (N)
% mv: Mean rearward speed (m/s)
% mnb1, mnb2: Mean number of bound clutches for both integrins
% mdint1, mdint2: Mean densities of both integrin types

Fs = nm.*fm1; %Stall force of the system 

% Initialize variables:

ts = 5e-3; % Time step used for calculation
f = []; %Total force on the substrate as a function of time
v = []; %Rearward speed as a function of time
t = 0; %Time vector
nb1 = []; % Total number of bound clutches, integrin 1
nb2 = []; % Total number of bound clutches, integrin 2
xsub = 0; %Substrate displacement
bound = zeros(nc,1); % Binding status of each clutch (0 unbound, 1 1st integrin, 2 2nd integrin)
folding = zeros(nc,1); % Folding status of each clutch (0 folded, 1 unfolded, 2 vinculin-bound)
xc = zeros(nc,1); %displacement of each clutch
Fc = zeros(nc,1); % Force in each clutch
dint1i = dint1; %Density of integrin type 1 before reinforcement
dint2i = dint2; %Density of integrin type 2 before reinforcement
dint1t = []; % Density of integrin type 1 as a function of time
dint2t = []; % Density of integrin type 2 as a function of time

for t=0:ts:100;


koff1 = kof1*koffcb(Fc,ion); % koff 1 in each clutch
koff2 = kof2*koffcb(Fc,ion); %koff 2 in each clutch
kuf = 1.*exp(-7.573).*exp(1.786e12.*abs(Fc).*pt); % k unfolding in each clutch
kf = 1.*exp(13.07).*exp(-2.288e12.*abs(Fc).*pt); % k refolding in each clutch


vf = vu.*(1 - ksub.*xsub./Fs); % Filament speed


% For bound clutches, we create vector k (koff) and vectors kvuf
% (unfolding) and kvf (refolding)
% for unbound clutches, we create two vectors k1 and k2 with kon


k = zeros(nc,1);
kvuf = zeros(nc,1);
kvf = zeros(nc,1);
k1 = zeros(nc,1);
k2 = zeros(nc,1);
indbound1 = find(bound == 1);
indbound2 = find(bound == 2);
indunbound = find(bound == 0);
k(indbound1) = koff1(indbound1);
k(indbound2) = koff2(indbound2);
kvuf(indbound1) = kuf(indbound1);
kvuf(indbound2) = kuf(indbound2);
kvf(indbound1) = kf(indbound1);
kvf(indbound2) = kf(indbound2);
k1(indunbound) = kont1*dint1;
k2(indunbound) = kont2*dint2;

%We calculate the times for all events:
teventub = -log(rand(nc,1))./k;  %Times for unbinding events
teventb1 = -log(rand(nc,1))./(k1); %Times for binding events, int. 1
teventb2 = -log(rand(nc,1))./(k2); %Times for binding events, int. 2
teventuf = -log(rand(nc,1))./kvuf; % Times for unfolding events
teventuf(folding == 1) = 0; % If molecule is already unfolded we set unfolding time to 0
teventf = -log(rand(nc,1))./kvf; % Times for refolding events
teventvinc = -log(rand(nc,1))./(konv); % Time for vinculin binding

teventb2(teventb2 - teventb1 > 0) = ts +1; % If binding of int2 happens after binding of int1 we don't execute it.
teventvinc(teventvinc - teventf > 0) = ts +1; % If refolding happens before vinculin binding we don't execute vinculin binding. 
teventvinc(teventvinc - teventub > 0) = ts +1; % If unbinding happens before vinculin binding we don't execute vinculin binding. 

% We find which events happen before ts and execute them:
indub = find(teventub < ts);
indb1 = find(teventb1 < ts);
indb2 = find(teventb2 < ts);
induf = find(teventuf < ts);
indvinculin = find(teventuf + teventvinc < ts);

boundbefore = bound;
bound(indub) = 0;
bound(indb1) = 1;
bound(indb2) = 2;

folding(induf) = 1;
folding(indvinculin) = 2;

% For the bonds that unbind, we add integrins if vinculin is bound, and
% remove them if it is unbound.

dint1 = dint1 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 12));
dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 11));
dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 10));

if dint1 < dint1i;
    dint1 = dint1i;
elseif dint1 > mr;
    dint1 = mr;
end;

dint2 = dint2 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 22));
dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 21));
dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 20));

if dint2 < dint2i;
    dint2 = dint2i;
elseif dint2 > mr;
    dint2 = mr;
end;

%We now reset the folding vector for the unbound clutches:
folding(indub) = 0;


% We recalculate all elements:

boundbin = logical(bound);

xc = xc + vf.*ts.*boundbin; %Position of each clutch
xsub = kc.*sum(xc.*boundbin)./(ksub+sum(boundbin).*kc); %Substrate position
xc(bound == 0) = xsub;
f(end +1) = xsub.*ksub;  % Force on substrate
v(end +1) = vf;          % Actin rearward speed
nb1(end +1) = sum(bound == 1); % Number of bound clutches (integrin 1)
nb2(end +1) = sum(bound == 2); % Number of bound clutches (integrin 2)

if t == 0;
    dint1t(1) = dint1i;
    dint2t(1) = dint2i;
else;
    dint1t(end+1) = dint1;
    dint2t(end+1) = dint2;
end;
Fc = kc.*(xc - xsub); % Force in each clutch


end;

mf = mean(f); %Mean force on substrate
mv = mean(v); %Mean rearward speed
mnb1 = mean(nb1); % Mean number of bound clutches
mnb2 = mean(nb2); % Mean number of bound clutches
mdint1 = mean(dint1t); % Mean density, integrin 1
mdint2 = mean(dint2t); % Mean density, integrin 2

% mf = mean(f); %Mean force on substrate
% mv = mean(v); %Mean rearward speed
% mnb1 = mean(nb1); % Mean number of bound clutches
% mnb2 = mean(nb2); % Mean number of bound clutches
