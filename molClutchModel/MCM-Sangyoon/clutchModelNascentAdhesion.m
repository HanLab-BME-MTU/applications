function [mf,mv,mnb1,mnb2,mdint1,mdint2] = ...
    clutchModelNascentAdhesion(nm,fm1,vu,nc,dint1,dint2,kont1,...
                            kont2,kof1,kof2,kc,ksub,konv,pt,mr,intadd,ion,...
                            v_actin, dActin, tTotal)
% function [mf,mv,mnb1,mnb2,mdint1,mdint2] =
% clutchModelNascentAdhesion(nm,fm1,vu,nc,dint1,dint2,kont1,kont2,kof1,kof2,
%                            kc,ksub,konv,pt,mr,intadd,ion) 
% calculates the mean force on the substrate generated by a rearward
% flowing csk according to the model of Chan and Odde (Science, 2008). 
% In addition, this function considers 2 integrin populations with
% different kon and koff. 
% 
% Input Parameters of the model (default values from chan and odde listed):
%       nm      Number of myosin motors (= 75)
%       fm1     Stall force of 1 motor (N) (= -2e-12) 
%       vu      Unloaded myosin motor velocity (m/s) (= -120e-9)
%       nc      Number of molecular clutches (fibronectin molecules) (= 75)
%       dint1:  Density of integrin molecules, type 1 (integrins/um2).
%       dint2:  Density of integrin molecules, type 2 (integrins/um2).
%       kont1   True on-rate (um2/s), 1st integrin type (= 1) 
%       kont2   Same for 2nd integrin type
%       kof1    Koff for 1st integrin type (scaling factor with respect to data
%               from Kong et al JCB paper).
%       kof2    Same for 2nd integrin type.
%       kc      Clutch spring constant (we assume the same for both
%               integrins) (N/m) (= 5e-3)
%       ksub    Substrate spring constant (N/m) (= 0.1e-3; or
%               10.^([-2:0.1:2]).*1e-3)
%       konv    Binding rate between vinculin and unfolded talin
%       pt      Fraction of clutch force experienced by talin
%       rf      Threshold force that leads to reinforcement (addition of another
%               integrin)
%       mr      Maximum integrin density for each integrin
%       intadd  Number of integrins added per sq. micron every time reinforcement happens.
%       ion     mn or mg, to take corresponding koff data from kong et al JCB paper
%       v_actin Unloaded actin-polymerization-driven actin flow speed
%       dActin  Density of F-actin molecules (which can be low for
%               Arp2/3-inhibited actin and intermediate for
%               Formin-inhibited actin). (Need a reference, 300 for now for
%               control)
% 
% Output parameters
%       mf              Mean force on substrate (N)
%       mv              Mean rearward speed (m/s)
%       mnb1, mnb2:     Mean number of bound clutches for both integrins
%       mdint1, mdint2: Mean densities of both integrin types
% 
% Adapted from Roca-cusachs,
% Sangyoon Han, December 2020

%% Initialize variables:
verbose = 1;
Fs = nm.*fm1; %Stall force of the system 
kB = 1.38064852e-23; %m2 kg s-2 K-1
T = 278; %K
% deltaActin = 2.7e-9; % m
c = 0.8; %c is a coefficient that accounts for geometrical effects: 0.13 is for sphere, maybe 1 for a flat edge. 
C_actin = kB*T*c*dActin; %constant for force-velocity relationship in actin: This is assumption for now 
R = 1e-6; % m, the radius of curvature of edge. Given normal cell, it can be ~ 10-30 um

ts = 5e-3; % Time step used for calculation
if nargin<20
    tTotal = 100; % total time period
end
xsub = 0; %Substrate displacement
bound = zeros(nc,1); % Binding status of each clutch (0 unbound, 1 1st integrin, 2 2nd integrin)
folding = zeros(nc,1); % Folding status of each clutch (0 folded, 1 unfolded, 2 vinculin-bound)
xc = zeros(nc,1); %displacement of each clutch
Fc = zeros(nc,1); % Force in each clutch
dint1i = dint1; %Density of integrin type 1 before reinforcement
dint2i = dint2; %Density of integrin type 2 before reinforcement
timeStepAll = 0:ts:tTotal;
nTimeSteps = numel(timeStepAll);
f = zeros(1,nTimeSteps); %Total force on the substrate as a function of time
v = zeros(1,nTimeSteps);  %Rearward speed as a function of time
nb1 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 1
nb2 = zeros(1,nTimeSteps); % Total number of bound clutches, integrin 2
dint1t = zeros(1,nTimeSteps); % Density of integrin type 1 as a function of time
dint2t = zeros(1,nTimeSteps); % Density of integrin type 2 as a function of time

%% Simulation through time
p = 0;
if verbose
    f100=figure(100); f100.Position(3:4)=[300 1000];
end
Fs_actin = -C_actin/(4*R);

for t=timeStepAll
    p = p + 1;
    koff1 = kof1*koffcb(Fc,ion); % koff 1 in each clutch
    koff2 = kof2*koffcb(Fc,ion); %koff 2 in each clutch
    kuf = 1.*exp(-7.573).*exp(1.786e12.*abs(Fc).*pt); % k unfolding in each clutch
    kf = 1.*exp(13.07).*exp(-2.288e12.*abs(Fc).*pt); % k refolding in each clutch

    % velocity is determined by the force (inversely with the force by clutch = traction)
    % This is something that's needed to be updated as the actin retrograde
    % flow is not only due to myosin. For myosin-free simulation, vu, the
    % unloaded myosin motor velocity, should be zero. 
    vf = vu.*(1 - ksub.*xsub./Fs) + C_actin/(-4*ksub.*xsub*R+C_actin)*v_actin; % - 0.2*v_actin; % v_actin*(1-ksub.*xsub./Fs_actin); 

    % For bound clutches, we create vector k (koff) and vectors kvuf
    % (unfolding) and kvf (refolding)
    % for unbound clutches, we create two vectors k1 and k2 with kon

    k = zeros(nc,1);
    kvuf = zeros(nc,1);
    kvf = zeros(nc,1);
    k1 = zeros(nc,1);
    k2 = zeros(nc,1);
    indbound1 = find(bound == 1);
    indbound2 = find(bound == 2);
    indunbound = find(bound == 0);
    k(indbound1) = koff1(indbound1);
    k(indbound2) = koff2(indbound2);
    kvuf(indbound1) = kuf(indbound1);
    kvuf(indbound2) = kuf(indbound2);
    kvf(indbound1) = kf(indbound1);
    kvf(indbound2) = kf(indbound2);
    k1(indunbound) = kont1*dint1;
    k2(indunbound) = kont2*dint2;

    %We calculate the times for all events:
    teventub = -log(rand(nc,1))./k;  %Times for unbinding events
    teventb1 = -log(rand(nc,1))./(k1); %Times for binding events, int. 1
    teventb2 = -log(rand(nc,1))./(k2); %Times for binding events, int. 2
    teventuf = -log(rand(nc,1))./kvuf; % Times for unfolding events
    teventuf(folding == 1) = 0; % If molecule is already unfolded we set unfolding time to 0
    teventf = -log(rand(nc,1))./kvf; % Times for refolding events
    teventvinc = -log(rand(nc,1))./(konv); % Time for vinculin binding

    % If binding of int2 happens after binding of int1 we don't execute it.
    teventb2(teventb2 - teventb1 > 0) = ts +1; 
    % If refolding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventf > 0) = ts +1; 
    % If unbinding happens before vinculin binding we don't execute
    % vinculin binding.  
    teventvinc(teventvinc - teventub > 0) = ts +1; 

    % We find which events happen before ts and execute them:
    indub = (teventub < ts);
    indb1 = (teventb1 < ts);
    indb2 = (teventb2 < ts);
    induf = (teventuf < ts);
    indvinculin = (teventuf + teventvinc < ts);

    boundbefore = bound;
    bound(indub) = 0;
    bound(indb1) = 1;
    bound(indb2) = 2;

    folding(induf) = 1;
    folding(indvinculin) = 2;

    % For the bonds that unbind, we add integrins if vinculin is bound, and
    % remove them if it is unbound.

    dint1 = dint1 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 12));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 11));
    dint1 = dint1 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 10));

    if dint1 < dint1i
        dint1 = dint1i;
    elseif dint1 > mr
        dint1 = mr;
    end

    dint2 = dint2 + intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 22));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 21));
    dint2 = dint2 - intadd.*length(find(folding(indub)+ boundbefore(indub).*10 == 20));

    if dint2 < dint2i
        dint2 = dint2i;
    elseif dint2 > mr
        dint2 = mr;
    end

    %We now reset the folding vector for the unbound clutches:
    folding(indub) = 0;

    % We recalculate all elements:
    boundbin = logical(bound); % when there is no bound clutch at all, force will be zero

    xc = xc + vf.*ts.*boundbin; %Position of each clutch
    xsub = kc.*sum(xc.*boundbin)./(ksub+sum(boundbin).*kc); %Substrate position
    xc(bound == 0) = xsub;
    f(p) = xsub.*ksub;  % Force on substrate
    v(p) = vf;          % Actin rearward speed
    nb1(p) = sum(bound == 1); % Number of bound clutches (integrin 1)
    nb2(p) = sum(bound == 2); % Number of bound clutches (integrin 2)

    if t == 0
        dint1t(1) = dint1i;
        dint2t(1) = dint2i;
    else
        dint1t(p) = dint1;
        dint2t(p) = dint2;
    end
    Fc = kc.*(xc - xsub); % Force in each clutch
    
end
q=1000;
if verbose 
    subplot(4,1,1); plot(1:q,abs(f(1:q)),'.-'); title('f')
    subplot(4,1,2); plot(1:q,abs(v(1:q)));  title('v')
    subplot(4,1,3); plot(1:q,nb1(1:q));  title('nb1')
    subplot(4,1,4); plot(1:q,nb2(1:q));  title('nb2')
    drawnow
end

mf = mean(f); %Mean force on substrate
mv = mean(v); %Mean rearward speed
mnb1 = mean(nb1); % Mean number of bound clutches
mnb2 = mean(nb2); % Mean number of bound clutches
mdint1 = mean(dint1t); % Mean density, integrin 1
mdint2 = mean(dint2t); % Mean density, integrin 2

% mf = mean(f); %Mean force on substrate
% mv = mean(v); %Mean rearward speed
% mnb1 = mean(nb1); % Mean number of bound clutches
% mnb2 = mean(nb2); % Mean number of bound clutches
