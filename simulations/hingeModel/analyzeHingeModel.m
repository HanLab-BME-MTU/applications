function [errFlag,dataStats,dataStats3] = analyzeHingeModel(model,modelParam,...
    initialState,runInfo,saveTraj,saveStats,hingeParam,hingeInit)
%ANALYZEHINGEMODEL statistically analyzes trajectories of microtubules
%
%SYNOPSIS [errFlag,dataStats,dataStats3] = analyzeHingeModel(model,modelParam,...
%    initialState,runInfo,saveTraj,saveStats,hingeParam,hingeInit)
%
%INPUT  model        : model of interest. 1 - mtDynInstability,
%                      2 - mtGTPCapLDepK.
%       modelParam   : Parameters needed for the model of interest.
%       initialState : Variables defining the initial state of the
%                      microtubule, according to the model of interest.
%       runInfo      : Structure containing information for run(s):
%           .maxNumSim    : Number of simulations to be done using given
%                           model and parameters.
%           .totalTime    : Total time of each simulation, in seconds.
%           .simTimeStep  : Time intervale used in simulations, in seconds.
%           .timeEps      : Value of the product of simulation time step and 
%                           maximum rate constant.
%           .expTimeStep  : Time interval, in seconds, at which experimental 
%                           measurements are taken.
%           .aveInterval  : Time interval, in seconds, over which
%                           simulation data is averaged to "reproduce" experimental data.
%           .analyzeOpt   : Option to pass to calcMTDynamics, equivalent to
%                           analysisType (See calcMTDynamics for details).
%       saveTraj     : Array of structures defining whether and where trajectories
%                      generated by mtGTPCapLDepK will be saved. It
%                      contains two elements, saveOrNot and fileName, which
%                      are both described below for saveStats.
%       saveStats    : Structure defining whether and where results will be
%                      saved.
%           .saveOrNot    : 1 if user wants to save, 0 if not.
%           .fileName     : name (including location) of file where results 
%                           will be saved. If empty and saveOrNot is 1, the name
%                           is chosen automatically to be
%                           "dataStats-day-month-year-hour-minute-second",
%                           and the data is saved in directory where
%                           function is called from.
%       hingeParam   : Parameters needed for the hinge model of GFP tag
%                      next to kinetochore.
%       hingeInit    : Initial position of tag.
%
%OUTPUT errFlag    : 0 if function executes normally, 1 otherwise.
%       dataStats  : Statistical descriptors of trajectory without tag. 
%       dataStats3 : Statistical descriptors of trajectory with tag.
%
%Khuloud Jaqaman, 9/03

errFlag = 0;

%check if correct number of arguments were used when function was called
if nargin ~= nargin('analyzeHingeModel')
    disp('--analyzeHingeModel: Incorrect number of input arguments!');
    errFlag  = 1;
    return;
end

maxNumSim   = runInfo.maxNumSim;
totalTime   = runInfo.totalTime;
simTimeStep = runInfo.simTimeStep;
timeEps     = runInfo.timeEps;
expTimeStep = runInfo.expTimeStep;
aveInterval = runInfo.aveInterval;
analyzeOpt  = runInfo.analyzeOpt;

%check input data
if length(saveTraj) ~= maxNumSim
    disp('--analyzeHingeModel: The size of array saveTraj should be equal to maxNumSim!')
    errFlag = 1;
    return;
end

if model ~= 1 && model ~= 2
    disp('--analyzeHingeModel: The variable "model" should be either 1 or 2!');
    errFlag = 1;
end
if maxNumSim < 1
    disp('--analyzeHingeModel: At least 1 simulation should be done!');
    errFlag = 1;
end
if totalTime <= 0
    disp('--analyzeHingeModel: Total time should be positive!');
    errFlag = 1;
end
if simTimeStep <= 0
    disp('--analyzeHingeModel: Simulation time step should be positive!');
    errFlag = 1;
end
if timeEps > 1
    disp('--analyzeHingeModel: The product of the time step and maximum rate ');
    disp('  constant should be smaller than 1!');
    errFlag = 1;
end
if expTimeStep <= 0
    disp('--analyzeHingeModel: Experimental time step should be positive!');
    errFlag = 1;
end
if aveInterval <= 0
    disp('--analyzeHingeModel: Averaging interval should be positive and smaller than exp. time step!');
    errFlag = 1;
end
if analyzeOpt ~= 1 && analyzeOpt ~= 2 and analyzeOpt ~= 3
    disp('--analyzeHingeModel: "analyzeOpt" should be 1, 2 or 3!');
    errFlag = 1;
end
for bigIter = 1:maxNumSim
    if saveTraj(bigIter).saveOrNot ~= 0 && saveTraj(bigIter).saveOrNot ~= 1
        disp('--analyzeHingeModel: "saveTraj.saveOrNot" should be 0 or 1!');
        errFlag = 1;
    end
end
if saveStats.saveOrNot ~= 0 && saveStats.saveOrNot ~= 1
    disp('--analyzeHingeModel: "saveStats.saveOrNot" should be 0 or 1!');
    errFlag = 1;
end
if errFlag
    disp('--analyzeHingeModel: Please fix input data!');
    return;
end

%in case a non-integer value is assigned to maxNumSim,
maxNumSim = round(maxNumSim); %round it to nearest integer

%make sure simTimeStep is at least 2 times smaller than aveInterval
if simTimeStep > aveInterval/2
    simTimeStep = aveInterval/2;
end

%get maxNumSim trajectories of totalTime seconds each 
for bigIter = 1:maxNumSim
    
    %get MT trajectory (stored in mtLength) under current conditions.
    %forcedRescue: stores time points at which rescue is forced in model #1.
    %capSize: stores number of GTP-"units" making up cap at every time step
    %in model #2.
    switch model
        case 1
            [mtLength1,forcedRescue,errFlag] = mtDynInstability(...
                modelParam,initialState,totalTime+expTimeStep,...
                simTimeStep,timeEps);
            if errFlag
                return;
            end
            mtLength(:,bigIter) = mtLength1;
        case 2
            [mtLength1,capSize1,errFlag] = mtGTPCapLDepK(modelParam,...
                initialState,totalTime+expTimeStep,simTimeStep,...
                timeEps,saveTraj(bigIter));
            if errFlag
                return;
            end
            mtLength(:,bigIter) = mtLength1;
            capSize(:,bigIter) = capSize1;
    otherwise
            disp('--analyzeHingeModel: The variable "model" should be either 1 or 2!');
            errFlag = 1;
            return;
    end
    
    %shift the whole trajectory to make it positive in case there are unphysical
    %negative lengths of MT that are not understood by "calcMTDynamics".
    minminLength(bigIter) = min(mtLength(:,bigIter));
    if minminLength(bigIter) < 0
        mtLength(:,bigIter) = mtLength(:,bigIter) - 1.1*minminLength(bigIter);
    else
        minminLength(bigIter) = 0;
    end
    
    %get position of tag relative to microtubule tip
    [tagPos,errFlag] = hingeModel(hingeParam,hingeInit,totalTime+expTimeStep,simTimeStep);
    
    %get SPB to Tag distance
    SPBToTag(:,1,bigIter) = mtLength(:,bigIter) + tagPos(:,1);
    SPBToTag(:,2,bigIter) = tagPos(:,2);
    SPBToTag(:,3,bigIter) = tagPos(:,3);
    
end

for bigIter = 1:maxNumSim
    %sample trajectory at instances of experimental measurement (expTimeStep). 
    %Use the average value of the position and its standard deviation in 
    %an appropriate interval (aveInterval) around the instance as the 
    %position and error at that instance.
    [mtLengthAve,mtLengthSD,errFlag] = averageMtTraj(mtLength(:,bigIter),...
        simTimeStep,expTimeStep,aveInterval);
    if errFlag
        return;
    end
    for i=1:3
        [SPBToTagAve(:,i),SPBToTagSD(:,i),errFlag] = averageMtTraj(...
            SPBToTag(:,i,bigIter),simTimeStep,expTimeStep,aveInterval);
    end
    if errFlag
        return;
    end
    
    %write data in correct format for calcMTDynamics
    [inputDataEntry,errFlag] = getAnaDat(mtLengthAve,mtLengthSD,bigIter,...
        expTimeStep,aveInterval);
    inputData(bigIter) = inputDataEntry;
    [inputDataEntry,errFlag] = getAnaDat3(SPBToTagAve,SPBToTagSD,bigIter,...
        expTimeStep,aveInterval);
    inputData3(bigIter) = inputDataEntry;
    
end

%analyze trajectories using experimental sampling rate and appropriate averaging interval
varargout = calcMTDynamics(inputData,0,0,0,[],analyzeOpt);
varargout3 = calcMTDynamics(inputData3,0,0,0,[],analyzeOpt);

%%%%%%%%%%%%%%%%%%%%
%%THIS SECTION MUST BE FIXED TO ACCOMODATE ALL CASES!!!%%

%save analysis results in dataStats and shift trajectory back to what it
%was before the correction
for bigIter = 1:maxNumSim
    dataStats(bigIter) = varargout(bigIter).statistics;
    if minminLength(bigIter) ~= 0
        dataStats(bigIter).distanceMean(1) = dataStats(bigIter).distanceMean(1)...
            + 1.1*minminLength(bigIter);
        dataStats(bigIter).minDistance(1) = dataStats(bigIter).minDistance(1)...
            + 1.1*minminLength(bigIter);
        dataStats(bigIter).minDistanceM5(1) = dataStats(bigIter).minDistanceM5(1)...
            + 1.1*minminLength(bigIter);
        dataStats(bigIter).maxDistance(1) = dataStats(bigIter).maxDistance(1)...
            + 1.1*minminLength(bigIter);
        dataStats(bigIter).maxDistanceM5(1) = dataStats(bigIter).maxDistanceM5(1)...
            + 1.1*minminLength(bigIter);
    end
end
for bigIter = 1:maxNumSim
    dataStats3(bigIter) = varargout3(bigIter).statistics;
    if minminLength(bigIter) ~= 0
        dataStats3(bigIter).distanceMean(1) = dataStats3(bigIter).distanceMean(1)...
            + 1.1*minminLength(bigIter);
        dataStats3(bigIter).minDistance(1) = dataStats3(bigIter).minDistance(1)...
            + 1.1*minminLength(bigIter);
        dataStats3(bigIter).minDistanceM5(1) = dataStats3(bigIter).minDistanceM5(1)...
            + 1.1*minminLength(bigIter);
        dataStats3(bigIter).maxDistance(1) = dataStats3(bigIter).maxDistance(1)...
            + 1.1*minminLength(bigIter);
        dataStats3(bigIter).maxDistanceM5(1) = dataStats3(bigIter).maxDistanceM5(1)...
            + 1.1*minminLength(bigIter);
    end
end

%do the same for the combined analysis of all trajectories
% minLengthAll = min(minminLength);
% dataStats(maxNumSim+1) = varargout(end).statistics;
% if minLengthAll ~= 0
%     dataStats(maxNumSim+1).distanceMean(1) = dataStats(maxNumSim+1).distanceMean(1)...
%         + 1.1*minLengthAll;
%     dataStats(maxNumSim+1).minDistance(1) = dataStats(maxNumSim+1).minDistance(1)...
%         + 1.1*minLengthAll;
%     dataStats(maxNumSim+1).minDistanceM5(1) = dataStats(maxNumSim+1).minDistanceM5(1)...
%         + 1.1*minLengthAll;
%     dataStats(maxNumSim+1).maxDistance(1) = dataStats(maxNumSim+1).maxDistance(1)...
%         + 1.1*minLengthAll;
%     dataStats(maxNumSim+1).maxDistanceM5(1) = dataStats(maxNumSim+1).maxDistanceM5(1)...
%         + 1.1*minLengthAll;
% end

%%%%%%%%%%%%%%%%%%%

%save data if user wants to
if saveStats.saveOrNot
    if isempty(saveStats.fileName)
        save(['dataStats-',nowString],'dataStats','dataStats3'); %save in file
    else
        save(saveStats.fileName,'dataStats','dataStats3'); %save in file (directory specified through name)
    end
end

