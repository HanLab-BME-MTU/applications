function [outImage, backgroundLevel] = ptGetProcessedImage (varargin)
% ptGetProcessedImage uses a number of image filtering functions to improve the
% image quality of the phase-contrast cell images so that an optimal segmentation 
% can take place. In particular the functions imVarianceImage, imMinimumThreshold 
% and im2bw are used.
%
% SYNOPSIS       outImage = ptGetProcessedImage (varargin)
%
% INPUT          inputImage: the image that has to be processed
%                greyMax:    the maximum greylevel value of the image (eg 4095 for a 12-bit image)
%                kernelSize: this should be an odd value and is used to calculate the variance image
%                            (15 is uaually a good value)
%
% OUTPUT         outImage       : the processed image which can be used for segmentation
%                backgroundLevel: the average level of the subtracted background
%
% DEPENDENCIES   ptGetProcessedImage uses { imVarianceImage 
%                                           im2bw }
%                                  
%                ptGetProcessedImage is used by { ptTrackCells }
%
% Revision History
% Name                  Date            Comment
% --------------------- --------        --------------------------------------------------------
% Andre Kerstens        Apr 04          Initial release
% Andre Kerstens        May 04          Function now uses automatic thresholding to find the background

% Test the number of input variables
if nargin < 3
   error('The input image, the maximum grey level (eg 4095 for a 12 bit image) and the kernel size (15 is a good value) have to be provided. See help ptGetProcessedImage.');
end

% Get the input variables
inputImage = varargin{1};
greyMax    = varargin{2};
kernelSize = varargin{3};

% Calculate the variance image
varImage = imVarianceImage (inputImage, kernelSize);

% Calculate the optimum threshold to segment this image
[threshold, J] = imMinimumThreshold (varImage, greyMax);

% Get the binary image where all of the background is 1
binImage = ~im2bw (varImage, threshold);

% Show only the background pixels in the original image (by multiplying with 
% the binary image). And then fetch the index of these specific pixels
newImage = inputImage .* binImage;
backOnlyImage = newImage (find (binImage));

% Get the x and y coordinates of these pixels
[x,y] = find (binImage);

% Now we start to solve the equation I(x,y) = f(x,y) where f(x,y) is ax^2+bxy+cy^2+d
% For this we need to create a matrix A = [x^2, xy, y^2, 1] to solve the coeff. 
% a, b, c and d (1 can be generated by ones(size(x),1)). The equation can then be solved
% by A \ backOnlyImage
one = ones(size(x,1),1);
A = [x.^2, x.*y, y.^2, one];
coeff = A \ backOnlyImage;

% Now calculate the background image using the estimated coefficients (we need
% the size of the whole input image this time so that we can subtract later.
[xi,yi] = find (inputImage);
backgroundImage = coeff(1).*(xi.^2) + coeff(2).*(xi.*yi) + coeff(3).*(yi.^2) + coeff(4);
%figure, mesh (reshape(backgroundImage,size(inputImage)));

% The average background level is approx. equal to the constant in the equation
backgroundLevel = coeff(4);

% Now we only have to subtract the background from the image and we're done
outImage = inputImage - reshape(backgroundImage,size(inputImage));

% Let's normalize the image back to [0..1] again
imageMinimum = min (min (outImage));
imageMaximum = max (max (outImage));
outImage = (outImage - imageMinimum) / (imageMaximum - imageMinimum);
